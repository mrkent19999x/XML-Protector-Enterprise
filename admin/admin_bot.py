#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
XML Protector Admin Bot - Telegram Bot t√≠ch h·ª£p
Qu·∫£n l√Ω t·∫•t c·∫£ EXE clients t·ª´ xa
"""

import os
import sys
import time
import json
import sqlite3
import logging
import requests
import threading
from datetime import datetime
from pathlib import Path

# --- SECURE CONFIG LOADING --- #
def load_admin_bot_config():
    """Load config an to√†n cho Admin Bot."""
    import os
    bot_token = os.getenv("XML_PROTECTOR_BOT_TOKEN", "")
    admin_ids_str = os.getenv("XML_PROTECTOR_ADMIN_IDS", "")
    
    if admin_ids_str:
        admin_ids = [int(x.strip()) for x in admin_ids_str.split(",") if x.strip()]
    else:
        admin_ids = []
    
    if not bot_token:
        raise Exception("‚ùå Bot token kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh! Set XML_PROTECTOR_BOT_TOKEN environment variable")
    
    return bot_token, admin_ids

# Load config
try:
    BOT_TOKEN, ADMIN_IDS = load_admin_bot_config()
except Exception as e:
    print(f"‚ùå ADMIN BOT CONFIG ERROR: {e}")
    BOT_TOKEN = ""
    ADMIN_IDS = []

# --- DATABASE --- #
DB_FILE = "xml_protector_admin.db"

# --- LOGGING --- #
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('admin_bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

class AdminBot:
    def __init__(self):
        self.bot_token = BOT_TOKEN
        self.admin_ids = ADMIN_IDS
        self.clients = {}  # L∆∞u tr·ªØ th√¥ng tin clients
        self.init_database()
        
    def init_database(self):
        """Kh·ªüi t·∫°o database."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # B·∫£ng clients
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS clients (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_name TEXT NOT NULL,
                    client_id TEXT UNIQUE NOT NULL,
                    exe_path TEXT,
                    status TEXT DEFAULT 'offline',
                    last_seen TIMESTAMP,
                    templates_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # B·∫£ng activities
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    activity_type TEXT,
                    description TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            # B·∫£ng alerts
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS alerts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    alert_type TEXT,
                    message TEXT,
                    severity TEXT DEFAULT 'info',
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            conn.commit()
            conn.close()
            logging.info("‚úÖ Database ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
            
        except Exception as e:
            logging.error(f"‚ùå L·ªói kh·ªüi t·∫°o database: {e}")
    
    def send_telegram_message(self, chat_id, message, reply_markup=None):
        """G·ª≠i message qua Telegram Bot."""
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                "chat_id": chat_id,
                "text": message,
                "parse_mode": "Markdown"
            }
            if reply_markup:
                data["reply_markup"] = json.dumps(reply_markup)
            
            response = requests.post(url, data=data)
            if response.status_code == 200:
                return True
            else:
                logging.warning(f"‚ùå L·ªói g·ª≠i Telegram: {response.status_code}")
                return False
        except Exception as e:
            logging.error(f"‚ùå G·ª≠i Telegram th·∫•t b·∫°i: {e}")
            return False
    
    def create_main_menu(self):
        """T·∫°o menu ch√≠nh cho admin - Enhanced v·ªõi Enterprise Management."""
        return {
            "inline_keyboard": [
                [
                    {"text": "üìä Master Dashboard", "callback_data": "master_dashboard"},
                    {"text": "üè¢ Doanh Nghi·ªáp", "callback_data": "companies_list"}
                ],
                [
                    {"text": "üñ•Ô∏è Clients Online", "callback_data": "clients_online"},
                    {"text": "üî¥ Clients Offline", "callback_data": "clients_offline"}
                ],
                [
                    {"text": "üèóÔ∏è Build & Deploy", "callback_data": "build_deploy_menu"},
                    {"text": "üì§ Mass Deploy", "callback_data": "mass_deploy"}
                ],
                [
                    {"text": "üö® Security Alerts", "callback_data": "security_alerts"},
                    {"text": "üìã Audit Logs", "callback_data": "audit_logs"}
                ],
                [
                    {"text": "üîÑ Mass Commands", "callback_data": "mass_commands"},
                    {"text": "üìä Analytics", "callback_data": "analytics"}
                ],
                [
                    {"text": "‚öôÔ∏è System Settings", "callback_data": "system_settings"},
                    {"text": "üÜò Emergency", "callback_data": "emergency_menu"}
                ]
            ]
        }
    
    def create_client_menu(self, client_id):
        """T·∫°o menu qu·∫£n l√Ω client c·ª• th·ªÉ."""
        return {
            "inline_keyboard": [
                [
                    {"text": "üìä Tr·∫°ng th√°i", "callback_data": f"client_status_{client_id}"},
                    {"text": "‚è∏Ô∏è T·∫°m d·ª´ng", "callback_data": f"client_pause_{client_id}"}
                ],
                [
                    {"text": "‚ñ∂Ô∏è Ti·∫øp t·ª•c", "callback_data": f"client_resume_{client_id}"},
                    {"text": "üîÑ Restart", "callback_data": f"client_restart_{client_id}"}
                ],
                [
                    {"text": "üìÅ Templates", "callback_data": f"client_templates_{client_id}"},
                    {"text": "üìã Logs", "callback_data": f"client_logs_{client_id}"}
                ],
                [
                    {"text": "üóëÔ∏è X√≥a Client", "callback_data": f"client_delete_{client_id}"},
                    {"text": "üîô Quay l·∫°i", "callback_data": "manage_clients"}
                ]
            ]
        }
    
    def handle_callback(self, callback_data, user_id, chat_id):
        """X·ª≠ l√Ω callback t·ª´ menu."""
        if user_id not in self.admin_ids:
            self.send_telegram_message(chat_id, "‚ùå **B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p!**")
            return
        
        try:
            # Master Dashboard v√† Enterprise Management
            if callback_data == "master_dashboard":
                self.show_master_dashboard(chat_id)
            elif callback_data == "companies_list":
                self.show_companies_list(chat_id)
            elif callback_data == "clients_online":
                self.show_clients_by_status(chat_id, "online")
            elif callback_data == "clients_offline":
                self.show_clients_by_status(chat_id, "offline")
            
            # Build & Deploy
            elif callback_data == "build_deploy_menu":
                self.show_build_deploy_menu(chat_id)
            elif callback_data == "mass_deploy":
                self.show_mass_deploy_menu(chat_id)
            
            # Security & Monitoring
            elif callback_data == "security_alerts":
                self.show_security_alerts(chat_id)
            elif callback_data == "audit_logs":
                self.show_audit_logs(chat_id)
            elif callback_data == "analytics":
                self.show_analytics(chat_id)
            
            # Mass Commands
            elif callback_data == "mass_commands":
                self.show_mass_commands_menu(chat_id)
            
            # System Settings
            elif callback_data == "system_settings":
                self.show_system_settings(chat_id)
            elif callback_data == "emergency_menu":
                self.show_emergency_menu(chat_id)
            
            # Legacy callbacks (backward compatibility)
            elif callback_data == "dashboard":
                self.show_dashboard(chat_id)
            elif callback_data == "manage_clients":
                self.show_clients_list(chat_id)
            elif callback_data == "build_exe":
                self.show_build_menu(chat_id)
            elif callback_data == "deploy":
                self.show_deploy_menu(chat_id)
            elif callback_data == "alerts":
                self.show_alerts(chat_id)
            elif callback_data == "reports":
                self.show_reports(chat_id)
            elif callback_data == "settings":
                self.show_settings(chat_id)
            elif callback_data == "help":
                self.show_help(chat_id)
            elif callback_data.startswith("client_"):
                self.handle_client_action(callback_data, chat_id)
            else:
                self.send_telegram_message(chat_id, f"‚ùå **L·ªánh kh√¥ng h·ª£p l·ªá:** `{callback_data}`")
                
        except Exception as e:
            logging.error(f"‚ùå L·ªói x·ª≠ l√Ω callback: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_dashboard(self, chat_id):
        """Hi·ªÉn th·ªã dashboard t·ªïng quan."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Th·ªëng k√™ t·ªïng quan
            cursor.execute("SELECT COUNT(*) FROM clients")
            total_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM clients WHERE status = 'online'")
            online_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM alerts WHERE severity = 'high'")
            high_alerts = cursor.fetchone()[0]
            
            conn.close()
            
            dashboard_text = f"""
üìä **DASHBOARD T·ªîNG QUAN**

üè¢ **T·ªïng s·ªë Clients:** `{total_clients}`
üü¢ **Online:** `{online_clients}`
üî¥ **Offline:** `{total_clients - online_clients}`
üö® **High Alerts:** `{high_alerts}`

‚è∞ **C·∫≠p nh·∫≠t:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
"""
            self.send_telegram_message(chat_id, dashboard_text, self.create_main_menu())
            
        except Exception as e:
            logging.error(f"‚ùå L·ªói hi·ªÉn th·ªã dashboard: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_clients_list(self, chat_id):
        """Hi·ªÉn th·ªã danh s√°ch clients."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT client_name, client_id, status, last_seen, templates_count 
                FROM clients 
                ORDER BY last_seen DESC
            """)
            clients = cursor.fetchall()
            conn.close()
            
            if not clients:
                self.send_telegram_message(chat_id, "üì≠ **Ch∆∞a c√≥ client n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω**", self.create_main_menu())
                return
            
            clients_text = "üñ•Ô∏è **DANH S√ÅCH CLIENTS**\n\n"
            
            for i, (name, client_id, status, last_seen, templates) in enumerate(clients, 1):
                status_emoji = "üü¢" if status == "online" else "üî¥"
                last_seen_str = last_seen if last_seen else "Ch∆∞a k·∫øt n·ªëi"
                
                clients_text += f"{i}. **{name}**\n"
                clients_text += f"   ID: `{client_id}`\n"
                clients_text += f"   Tr·∫°ng th√°i: {status_emoji} {status}\n"
                clients_text += f"   Templates: {templates} files\n"
                clients_text += f"   Cu·ªëi c√πng: {last_seen_str}\n\n"
            
            # T·∫°o menu cho t·ª´ng client
            keyboard = []
            for name, client_id, status, _, _ in clients:
                keyboard.append([{"text": f"{name} ({status})", "callback_data": f"client_menu_{client_id}"}])
            
            keyboard.append([{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}])
            
            reply_markup = {"inline_keyboard": keyboard}
            self.send_telegram_message(chat_id, clients_text, reply_markup)
            
        except Exception as e:
            logging.error(f"‚ùå L·ªói hi·ªÉn th·ªã clients: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_build_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build EXE."""
        build_text = """
üèóÔ∏è **BUILD EXE M·ªöI**

Ch·ªçn lo·∫°i EXE c·∫ßn build:

1. **üõ°Ô∏è Runtime Client** - B·∫£o v·ªá XML
2. **üèóÔ∏è Builder Tool** - T·∫°o EXE m·ªõi  
3. **ü§ñ Hybrid Bot** - V·ª´a b·∫£o v·ªá v·ª´a build
4. **üì± Mobile App** - ·ª®ng d·ª•ng di ƒë·ªông
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üõ°Ô∏è Runtime Client", "callback_data": "build_runtime"},
                    {"text": "üèóÔ∏è Builder Tool", "callback_data": "build_builder"}
                ],
                [
                    {"text": "ü§ñ Hybrid Bot", "callback_data": "build_hybrid"},
                    {"text": "üì± Mobile App", "callback_data": "build_mobile"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_deploy_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu deploy."""
        deploy_text = """
üì§ **DEPLOY & PH√ÇN PH·ªêI**

Ch·ªçn c√°ch deploy EXE:

1. **üì§ G·ª≠i qua Telegram** - G·ª≠i file EXE
2. **üåê Download Link** - T·∫°o link download
3. **üìß Email** - G·ª≠i qua email
4. **üîÑ Auto Update** - C·∫≠p nh·∫≠t t·ª± ƒë·ªông
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üì§ Telegram", "callback_data": "deploy_telegram"},
                    {"text": "üåê Download", "callback_data": "deploy_download"}
                ],
                [
                    {"text": "üìß Email", "callback_data": "deploy_email"},
                    {"text": "üîÑ Auto Update", "callback_data": "deploy_auto"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_alerts(self, chat_id):
        """Hi·ªÉn th·ªã alerts."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT a.alert_type, a.message, a.severity, a.timestamp, c.client_name
                FROM alerts a
                LEFT JOIN clients c ON a.client_id = c.client_id
                ORDER BY a.timestamp DESC
                LIMIT 10
            """)
            alerts = cursor.fetchall()
            conn.close()
            
            if not alerts:
                self.send_telegram_message(chat_id, "‚úÖ **Kh√¥ng c√≥ alert n√†o**", self.create_main_menu())
                return
            
            alerts_text = "üö® **ALERTS G·∫¶N ƒê√ÇY**\n\n"
            
            for alert_type, message, severity, timestamp, client_name in alerts:
                severity_emoji = {
                    "high": "üî¥",
                    "medium": "üü°", 
                    "low": "üü¢",
                    "info": "‚ÑπÔ∏è"
                }.get(severity, "‚ÑπÔ∏è")
                
                alerts_text += f"{severity_emoji} **{alert_type}**\n"
                alerts_text += f"   Client: {client_name or 'System'}\n"
                alerts_text += f"   Message: {message}\n"
                alerts_text += f"   Time: {timestamp}\n\n"
            
            keyboard = {
                "inline_keyboard": [
                    [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
                ]
            }
            
            self.send_telegram_message(chat_id, alerts_text, keyboard)
            
        except Exception as e:
            logging.error(f"‚ùå L·ªói hi·ªÉn th·ªã alerts: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_reports(self, chat_id):
        """Hi·ªÉn th·ªã reports."""
        reports_text = """
üìã **B√ÅO C√ÅO & TH·ªêNG K√ä**

Ch·ªçn lo·∫°i b√°o c√°o:

1. **üìä Performance** - Hi·ªáu su·∫•t h·ªá th·ªëng
2. **üö® Security** - B√°o c√°o b·∫£o m·∫≠t
3. **üí∞ Business** - B√°o c√°o kinh doanh
4. **üìà Analytics** - Ph√¢n t√≠ch d·ªØ li·ªáu
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üìä Performance", "callback_data": "report_performance"},
                    {"text": "üö® Security", "callback_data": "report_security"}
                ],
                [
                    {"text": "üí∞ Business", "callback_data": "report_business"},
                    {"text": "üìà Analytics", "callback_data": "report_analytics"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, reports_text, keyboard)
    
    def show_settings(self, chat_id):
        """Hi·ªÉn th·ªã settings."""
        settings_text = """
‚öôÔ∏è **C√ÄI ƒê·∫∂T H·ªÜ TH·ªêNG**

1. **üîë Bot Token** - C·∫•u h√¨nh bot
2. **üë• Admin Users** - Qu·∫£n l√Ω quy·ªÅn admin
3. **üìß Notifications** - C√†i ƒë·∫∑t th√¥ng b√°o
4. **üîÑ Auto Update** - C·∫≠p nh·∫≠t t·ª± ƒë·ªông
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üîë Bot Token", "callback_data": "setting_token"},
                    {"text": "üë• Admin Users", "callback_data": "setting_admins"}
                ],
                [
                    {"text": "üìß Notifications", "callback_data": "setting_notifications"},
                    {"text": "üîÑ Auto Update", "callback_data": "setting_auto_update"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, settings_text, keyboard)
    
    def show_help(self, chat_id):
        """Hi·ªÉn th·ªã help."""
        help_text = """
‚ùì **H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG**

ü§ñ **XML Protector Admin Bot**

**Ch·ª©c nƒÉng ch√≠nh:**
‚Ä¢ üìä Dashboard - Xem t·ªïng quan h·ªá th·ªëng
‚Ä¢ üñ•Ô∏è Qu·∫£n l√Ω Clients - Qu·∫£n l√Ω EXE clients
‚Ä¢ üèóÔ∏è Build EXE - T·∫°o EXE m·ªõi
‚Ä¢ üì§ Deploy - Ph√¢n ph·ªëi EXE
‚Ä¢ üö® Alerts - Th√¥ng b√°o c·∫£nh b√°o
‚Ä¢ üìã Reports - B√°o c√°o chi ti·∫øt

**L·ªánh c∆° b·∫£n:**
‚Ä¢ `/start` - Kh·ªüi ƒë·ªông bot
‚Ä¢ `/menu` - Hi·ªán menu ch√≠nh
‚Ä¢ `/help` - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
‚Ä¢ `/status` - Tr·∫°ng th√°i h·ªá th·ªëng

**Li√™n h·ªá h·ªó tr·ª£:**
‚Ä¢ Admin: @admin_username
‚Ä¢ Email: support@xmlprotector.com
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
            ]
        }
        
        self.send_telegram_message(chat_id, help_text, keyboard)
    
    def handle_client_action(self, callback_data, chat_id):
        """X·ª≠ l√Ω action v·ªõi client c·ª• th·ªÉ."""
        try:
            parts = callback_data.split("_")
            action = parts[1]
            client_id = parts[2] if len(parts) > 2 else None
            
            if action == "menu":
                self.show_client_menu(chat_id, client_id)
            elif action == "status":
                self.show_client_status(chat_id, client_id)
            elif action == "pause":
                self.pause_client(chat_id, client_id)
            elif action == "resume":
                self.resume_client(chat_id, client_id)
            elif action == "restart":
                self.restart_client(chat_id, client_id)
            elif action == "templates":
                self.show_client_templates(chat_id, client_id)
            elif action == "logs":
                self.show_client_logs(chat_id, client_id)
            elif action == "delete":
                self.delete_client(chat_id, client_id)
            else:
                self.send_telegram_message(chat_id, "‚ùå Action kh√¥ng h·ª£p l·ªá!")
                
        except Exception as e:
            logging.error(f"‚ùå L·ªói x·ª≠ l√Ω client action: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def start_telegram_webhook(self):
        """Kh·ªüi ƒë·ªông Telegram webhook."""
        def check_telegram_updates():
            offset = 0
            while True:
                try:
                    url = f"https://api.telegram.org/bot{self.bot_token}/getUpdates"
                    params = {"offset": offset, "timeout": 10}
                    response = requests.get(url, params=params)
                    
                    if response.status_code == 200:
                        data = response.json()
                        for update in data.get('result', []):
                            offset = update['update_id'] + 1
                            
                            if 'callback_query' in update:
                                callback_data = update['callback_query']['data']
                                user_id = update['callback_query']['from']['id']
                                chat_id = update['callback_query']['message']['chat']['id']
                                self.handle_callback(callback_data, user_id, chat_id)
                            
                            elif 'message' in update:
                                message = update['message']
                                user_id = message['from']['id']
                                chat_id = message['chat']['id']
                                text = message.get('text', '')
                                
                                if text == '/start' or text == '/menu':
                                    welcome_text = """
ü§ñ **XML PROTECTOR ADMIN BOT**

Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi h·ªá th·ªëng qu·∫£n l√Ω XML Protector!

Ch·ªçn ch·ª©c nƒÉng t·ª´ menu b√™n d∆∞·ªõi:
"""
                                    self.send_telegram_message(chat_id, welcome_text, self.create_main_menu())
                                
                                elif text == '/help':
                                    self.show_help(chat_id)
                                
                                elif text == '/status':
                                    self.show_dashboard(chat_id)
                                
                                else:
                                    # X·ª≠ l√Ω tin nh·∫Øn th√¥ng th∆∞·ªùng
                                    self.handle_text_message(text, user_id, chat_id)
                
                except Exception as e:
                    logging.error(f"‚ùå L·ªói Telegram webhook: {e}")
                    time.sleep(5)
                
                time.sleep(1)
        
        telegram_thread = threading.Thread(target=check_telegram_updates, daemon=True)
        telegram_thread.start()
        logging.info("‚úÖ Telegram webhook ƒë√£ kh·ªüi ƒë·ªông")
    
    def handle_text_message(self, text, user_id, chat_id):
        """X·ª≠ l√Ω tin nh·∫Øn text th√¥ng th∆∞·ªùng."""
        if user_id not in self.admin_ids:
            self.send_telegram_message(chat_id, "‚ùå **B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p!**")
            return
        
        # X·ª≠ l√Ω c√°c l·ªánh text
        if text.lower().startswith("build "):
            self.handle_build_command(text, chat_id)
        elif text.lower().startswith("deploy "):
            self.handle_deploy_command(text, chat_id)
        elif text.lower().startswith("client "):
            self.handle_client_command(text, chat_id)
        else:
            self.send_telegram_message(chat_id, "üí° G·ª≠i /menu ƒë·ªÉ xem c√°c t√πy ch·ªçn", self.create_main_menu())
    
    # === ENHANCED ENTERPRISE METHODS === #
    
    def show_master_dashboard(self, chat_id):
        """Hi·ªÉn th·ªã master dashboard t·ªïng quan to√†n h·ªá th·ªëng."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Enterprise-level statistics
            cursor.execute("SELECT COUNT(*) FROM clients")
            total_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM clients WHERE status = 'online'")
            online_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM alerts WHERE severity = 'high' AND timestamp > datetime('now', '-24 hours')")
            high_alerts_24h = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM activities WHERE timestamp > datetime('now', '-1 hours')")
            recent_activities = cursor.fetchone()[0]
            
            # Top active clients
            cursor.execute("""
                SELECT client_name, COUNT(*) as activity_count 
                FROM activities a
                JOIN clients c ON a.client_id = c.client_id
                WHERE a.timestamp > datetime('now', '-24 hours')
                GROUP BY a.client_id
                ORDER BY activity_count DESC
                LIMIT 3
            """)
            top_clients = cursor.fetchall()
            
            conn.close()
            
            # Create dashboard text
            dashboard_text = f"""
üéØ **XML PROTECTOR - MASTER CONTROL DASHBOARD**

üìä **T·ªîNG QUAN H·ªÜ TH·ªêNG:**
üè¢ **Total Enterprises:** `{total_clients}`
üü¢ **Online Now:** `{online_clients}`
üî¥ **Offline:** `{total_clients - online_clients}`
‚ö° **Uptime Ratio:** `{(online_clients/total_clients*100) if total_clients > 0 else 0:.1f}%`

üö® **B·∫¢O M·∫¨T 24H:**
üî• **High Alerts:** `{high_alerts_24h}`
üîÑ **Recent Activities:** `{recent_activities}`

üìà **TOP ACTIVE CLIENTS (24H):**
"""
            
            for i, (client_name, activity_count) in enumerate(top_clients, 1):
                dashboard_text += f"   {i}. **{client_name}:** `{activity_count} activities`\n"
            
            if not top_clients:
                dashboard_text += "   _Ch∆∞a c√≥ ho·∫°t ƒë·ªông n√†o_\n"
            
            dashboard_text += f"\n‚è∞ **Last Update:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`"
            
            self.send_telegram_message(chat_id, dashboard_text, self.create_main_menu())
            
        except Exception as e:
            logging.error(f"‚ùå L·ªói hi·ªÉn th·ªã master dashboard: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói Master Dashboard:** `{str(e)}`")
    
    def show_mass_commands_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu l·ªánh h√†ng lo·∫°t."""
        mass_text = """
üîÑ **MASS COMMANDS - ƒêI·ªÄU KHI·ªÇN H√ÄNG LO·∫†T**

Th·ª±c hi·ªán l·ªánh cho nhi·ªÅu client c√πng l√∫c:

üî¥ **Mass Pause** - T·∫°m d·ª´ng t·∫•t c·∫£ client
‚ñ∂Ô∏è **Mass Resume** - Kh·ªüi ƒë·ªông l·∫°i t·∫•t c·∫£ client  
üîÑ **Mass Restart** - Restart t·∫•t c·∫£ client
üìã **Mass Status** - L·∫•y tr·∫°ng th√°i t·∫•t c·∫£ client
üóëÔ∏è **Mass Cleanup** - D·ªçn d·∫πp log files
üì§ **Mass Update** - C·∫≠p nh·∫≠t templates m·ªõi

‚ö†Ô∏è **C·∫£nh b√°o:** C√°c l·ªánh n√†y s·∫Ω ·∫£nh h∆∞·ªüng ƒë·∫øn T·∫§T C·∫¢ client ƒëang ho·∫°t ƒë·ªông!
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üî¥ Mass Pause", "callback_data": "mass_pause_all"},
                    {"text": "‚ñ∂Ô∏è Mass Resume", "callback_data": "mass_resume_all"}
                ],
                [
                    {"text": "üîÑ Mass Restart", "callback_data": "mass_restart_all"},
                    {"text": "üìã Mass Status", "callback_data": "mass_status_all"}
                ],
                [
                    {"text": "üóëÔ∏è Mass Cleanup", "callback_data": "mass_cleanup_all"},
                    {"text": "üì§ Mass Update", "callback_data": "mass_update_all"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "master_dashboard"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, mass_text, keyboard)
    
    def run(self):
        """Ch·∫°y bot."""
        logging.info("üöÄ XML Protector Admin Bot ƒëang kh·ªüi ƒë·ªông...")
        
        # Kh·ªüi ƒë·ªông Telegram webhook
        self.start_telegram_webhook()
        
        # G·ª≠i th√¥ng b√°o kh·ªüi ƒë·ªông cho admin
        startup_msg = f"""
üöÄ **XML PROTECTOR ADMIN BOT ƒê√É KH·ªûI ƒê·ªòNG!**

‚è∞ **Th·ªùi gian:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
ü§ñ **Bot Token:** `{self.bot_token[:20]}...`
üë• **Admin IDs:** `{self.admin_ids}`

G·ª≠i /start ƒë·ªÉ b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng!
"""
        
        for admin_id in self.admin_ids:
            self.send_telegram_message(admin_id, startup_msg)
        
        logging.info("‚úÖ Admin Bot ƒë√£ s·∫µn s√†ng!")
        
        # Gi·ªØ bot ch·∫°y
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            logging.info("‚èπÔ∏è Admin Bot ƒë√£ t·∫Øt (KeyboardInterrupt)")
        except Exception as e:
            logging.error(f"‚ùå Admin Bot g·∫∑p l·ªói: {e}")

if __name__ == '__main__':
    bot = AdminBot()
    bot.run()
