#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
XML Protector - GUI Builder T√≠ch H·ª£p Ho√†n Ch·ªânh
Qu·∫£n l√Ω t·∫•t c·∫£ ch·ª©c nƒÉng t·ª´ 1 giao di·ªán duy nh·∫•t
"""

import os
import sys
import time
import glob
import json
import pickle
import shutil
import logging
import requests
import re
import xml.etree.ElementTree as ET
import threading
import subprocess
import psutil
import sqlite3
import uuid
from datetime import datetime
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, END
except ImportError:
    print("‚ùå C·∫ßn c√†i ƒë·∫∑t: tkinter")
    sys.exit(1)

try:
    import winreg
except ImportError:
    winreg = None

# Import security manager
try:
    from security_manager import SecurityManager, ConfigManager
except ImportError:
    SecurityManager = None
    ConfigManager = None

# --- SECURE CONFIG TEMPLATE --- #
SECURE_CONFIG_TEMPLATE = {
    "master_admin": {
        "admin_name": "XML Protector Master Admin",
        "admin_id": None,  # S·∫Ω ƒë∆∞·ª£c set trong GUI
        "created_at": None
    },
    "telegram": {
        "bot_token": "",  # S·∫Ω ƒë∆∞·ª£c nh·∫≠p trong GUI
        "master_chat_id": "",  # Chat ID c·ªßa admin ch√≠nh
        "admin_ids": []  # List admin IDs
    },
    "companies": {},  # Dictionary l∆∞u th√¥ng tin t·ª´ng c√¥ng ty
    "build_settings": {
        "auto_send_telegram": True,
        "include_guardian": True,
        "include_admin_bot": True,
        "auto_startup": True,
        "encryption_enabled": True
    },
    "security_settings": {
        "require_deployment_approval": True,
        "max_companies": 50,
        "deployment_expiry_days": 365,
        "audit_logging": True
    }
}

# --- DATABASE --- #
DB_FILE = "xml_protector_admin.db"

class AdminBot:
    """Bot qu·∫£n l√Ω t·ª´ xa."""
    
    def __init__(self, config):
        self.bot_token = config['telegram']['bot_token']
        self.admin_ids = config['telegram']['admin_ids']
        self.clients = {}
        self.init_database()
        # Kh√¥ng t·ª± ƒë·ªông kh·ªüi ƒë·ªông webhook
        print("‚úÖ AdminBot ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o (ch∆∞a kh·ªüi ƒë·ªông webhook)")
        
    def init_database(self):
        """Kh·ªüi t·∫°o database."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # B·∫£ng clients
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS clients (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_name TEXT NOT NULL,
                    client_id TEXT UNIQUE NOT NULL,
                    exe_path TEXT,
                    status TEXT DEFAULT 'offline',
                    last_seen TIMESTAMP,
                    templates_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # B·∫£ng activities
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    activity_type TEXT,
                    description TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            # B·∫£ng alerts
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS alerts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    alert_type TEXT,
                    message TEXT,
                    severity TEXT DEFAULT 'info',
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            conn.commit()
            conn.close()
            print("‚úÖ Database ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
            
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi t·∫°o database: {e}")
    
    def send_telegram_message(self, chat_id, message, reply_markup=None):
        """G·ª≠i message qua Telegram Bot."""
        try:
            # Ch·ªâ g·ª≠i v√†o group chat, kh√¥ng g·ª≠i ri√™ng cho admin
            if str(chat_id).startswith('-100') or str(chat_id).startswith('-'):
                # ƒê√¢y l√† group chat - OK ƒë·ªÉ g·ª≠i
                pass
            else:
                # ƒê√¢y l√† chat ri√™ng v·ªõi admin - b·ªè qua
                print(f"‚ö†Ô∏è B·ªè qua g·ª≠i message ri√™ng cho admin {chat_id}")
                return True
            
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                "chat_id": chat_id,
                "text": message,
                "parse_mode": "Markdown"
            }
            if reply_markup:
                data["reply_markup"] = json.dumps(reply_markup)
            
            response = requests.post(url, data=data)
            if response.status_code == 200:
                return True
            else:
                print(f"‚ùå L·ªói g·ª≠i Telegram: {response.status_code}")
                return False
        except Exception as e:
            print(f"‚ùå G·ª≠i Telegram th·∫•t b·∫°i: {e}")
            return False
    
    def create_main_menu(self):
        """T·∫°o menu ch√≠nh cho admin."""
        return {
            "inline_keyboard": [
                [
                    {"text": "üìä B·∫£ng ƒëi·ªÅu khi·ªÉn", "callback_data": "dashboard"},
                    {"text": "üñ•Ô∏è Qu·∫£n l√Ω Kh√°ch h√†ng", "callback_data": "manage_clients"}
                ],
                [
                    {"text": "üèóÔ∏è T·∫°o EXE", "callback_data": "build_exe"},
                    {"text": "üì§ Tri·ªÉn khai", "callback_data": "deploy"}
                ],
                [
                    {"text": "üö® C·∫£nh b√°o", "callback_data": "alerts"},
                    {"text": "üìã B√°o c√°o", "callback_data": "reports"}
                ],
                [
                    {"text": "‚öôÔ∏è C√†i ƒë·∫∑t", "callback_data": "settings"},
                    {"text": "‚ùì Tr·ª£ gi√∫p", "callback_data": "help"}
                ]
            ]
        }
    
    def start_telegram_webhook(self):
        """Kh·ªüi ƒë·ªông Telegram webhook."""
        def check_telegram_updates():
            offset = 0
            while True:
                try:
                    url = f"https://api.telegram.org/bot{self.bot_token}/getUpdates"
                    params = {"offset": offset, "timeout": 10}
                    response = requests.get(url, params=params)
                    
                    if response.status_code == 200:
                        data = response.json()
                        for update in data.get('result', []):
                            offset = update['update_id'] + 1
                            
                            if 'callback_query' in update:
                                callback_data = update['callback_query']['data']
                                user_id = update['callback_query']['from']['id']
                                chat_id = update['callback_query']['message']['chat']['id']
                                self.handle_callback(callback_data, user_id, chat_id)
                            
                            elif 'message' in update:
                                message = update['message']
                                user_id = message['from']['id']
                                chat_id = message['chat']['id']
                                text = message.get('text', '')
                                
                                if text == '/start' or text == '/menu':
                                    welcome_text = """
ü§ñ **XML PROTECTOR ADMIN BOT**

Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi h·ªá th·ªëng qu·∫£n l√Ω XML Protector!

Ch·ªçn ch·ª©c nƒÉng t·ª´ menu b√™n d∆∞·ªõi:
"""
                                    self.send_telegram_message(chat_id, welcome_text, self.create_main_menu())
                
                except Exception as e:
                    print(f"‚ùå L·ªói Telegram webhook: {e}")
                    time.sleep(5)
                
                time.sleep(1)
        
        telegram_thread = threading.Thread(target=check_telegram_updates, daemon=True)
        telegram_thread.start()
        print("‚úÖ Telegram webhook ƒë√£ kh·ªüi ƒë·ªông")
    
    def handle_callback(self, callback_data, user_id, chat_id):
        """X·ª≠ l√Ω callback t·ª´ menu."""
        if user_id not in self.admin_ids:
            self.send_telegram_message(chat_id, "‚ùå **B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p!**")
            return
        
        try:
            print(f"üîç X·ª≠ l√Ω callback: {callback_data} t·ª´ user {user_id}")
            
            if callback_data == "dashboard" or callback_data == "main_menu":
                self.show_dashboard(chat_id)
            elif callback_data == "manage_clients":
                self.show_clients_list(chat_id)
            elif callback_data == "build_exe":
                self.show_build_menu(chat_id)
            elif callback_data == "deploy":
                self.show_deploy_menu(chat_id)
            elif callback_data == "alerts":
                self.show_alerts(chat_id)
            elif callback_data == "reports":
                self.show_reports(chat_id)
            elif callback_data == "settings":
                self.show_settings(chat_id)
            elif callback_data == "help":
                self.show_help(chat_id)
            elif callback_data == "build_runtime":
                self.show_build_runtime_menu(chat_id)
            elif callback_data == "build_builder":
                self.show_build_builder_menu(chat_id)
            elif callback_data == "build_hybrid":
                self.show_build_hybrid_menu(chat_id)
            elif callback_data == "build_mobile":
                self.show_build_mobile_menu(chat_id)
            elif callback_data == "deploy_telegram":
                self.show_deploy_telegram_info(chat_id)
            elif callback_data == "deploy_web":
                self.show_deploy_web_info(chat_id)
            elif callback_data == "deploy_local":
                self.show_deploy_local_info(chat_id)
            elif callback_data == "deploy_package":
                self.show_deploy_package_info(chat_id)
            elif callback_data == "advanced_settings":
                self.show_advanced_settings(chat_id)
            else:
                print(f"‚ö†Ô∏è Callback kh√¥ng x√°c ƒë·ªãnh: {callback_data}")
                self.send_telegram_message(chat_id, "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!")
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω callback: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_dashboard(self, chat_id):
        """Hi·ªÉn th·ªã dashboard t·ªïng quan."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Th·ªëng k√™ t·ªïng quan
            cursor.execute("SELECT COUNT(*) FROM clients")
            total_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM clients WHERE status = 'online'")
            online_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM alerts WHERE severity = 'high'")
            high_alerts = cursor.fetchone()[0]
            
            conn.close()
            
            dashboard_text = f"""
üìä **DASHBOARD T·ªîNG QUAN**

üè¢ **T·ªïng s·ªë Clients:** `{total_clients}`
üü¢ **Online:** `{online_clients}`
üî¥ **Offline:** `{total_clients - online_clients}`
üö® **High Alerts:** `{high_alerts}`

‚è∞ **C·∫≠p nh·∫≠t:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
"""
            self.send_telegram_message(chat_id, dashboard_text, self.create_main_menu())
            
        except Exception as e:
            print(f"‚ùå L·ªói hi·ªÉn th·ªã dashboard: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_build_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build EXE."""
        build_text = """
üèóÔ∏è **BUILD EXE M·ªöI**

Ch·ªçn lo·∫°i EXE c·∫ßn build:

1. **üõ°Ô∏è Runtime Client** - B·∫£o v·ªá XML
2. **üèóÔ∏è Builder Tool** - T·∫°o EXE m·ªõi  
3. **ü§ñ Hybrid Bot** - V·ª´a b·∫£o v·ªá v·ª´a build
4. **üì± Mobile App** - ·ª®ng d·ª•ng di ƒë·ªông
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üõ°Ô∏è Client B·∫£o v·ªá", "callback_data": "build_runtime"},
                    {"text": "üèóÔ∏è C√¥ng c·ª• T·∫°o", "callback_data": "build_builder"}
                ],
                [
                    {"text": "ü§ñ Bot ƒêa nƒÉng", "callback_data": "build_hybrid"},
                    {"text": "üì± ·ª®ng d·ª•ng Di ƒë·ªông", "callback_data": "build_mobile"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_help(self, chat_id):
        """Hi·ªÉn th·ªã help."""
        help_text = """
‚ùì **H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG**

ü§ñ **XML Protector Admin Bot**

**Ch·ª©c nƒÉng ch√≠nh:**
‚Ä¢ üìä Dashboard - Xem t·ªïng quan h·ªá th·ªëng
‚Ä¢ üñ•Ô∏è Qu·∫£n l√Ω Clients - Qu·∫£n l√Ω EXE clients
‚Ä¢ üèóÔ∏è Build EXE - T·∫°o EXE m·ªõi
‚Ä¢ üì§ Deploy - Ph√¢n ph·ªëi EXE
‚Ä¢ üö® Alerts - Th√¥ng b√°o c·∫£nh b√°o
‚Ä¢ üìã Reports - B√°o c√°o chi ti·∫øt

**L·ªánh c∆° b·∫£n:**
‚Ä¢ `/start` - Kh·ªüi ƒë·ªông bot
‚Ä¢ `/menu` - Hi·ªán menu ch√≠nh
‚Ä¢ `/help` - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
‚Ä¢ `/status` - Tr·∫°ng th√°i h·ªá th·ªëng
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
            ]
        }
        
        self.send_telegram_message(chat_id, help_text, keyboard)
    
    def show_clients_list(self, chat_id):
        """Hi·ªÉn th·ªã danh s√°ch clients."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("SELECT client_name, client_id, status, last_seen FROM clients ORDER BY last_seen DESC LIMIT 10")
            clients = cursor.fetchall()
            conn.close()
            
            if clients:
                clients_text = "üìã **DANH S√ÅCH CLIENTS**\n\n"
                for i, (name, client_id, status, last_seen) in enumerate(clients, 1):
                    clients_text += f"{i}. **{name}**\n   ID: `{client_id}`\n   Tr·∫°ng th√°i: {status}\n   Cu·ªëi c√πng: {last_seen}\n\n"
            else:
                clients_text = "üìã **DANH S√ÅCH CLIENTS**\n\n‚ùå Ch∆∞a c√≥ client n√†o"
            
            keyboard = {
                "inline_keyboard": [
                    [{"text": "üîÑ L√†m m·ªõi", "callback_data": "manage_clients"}],
                    [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
                ]
            }
            
            self.send_telegram_message(chat_id, clients_text, keyboard)
            
        except Exception as e:
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_deploy_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu deploy."""
        deploy_text = """
üì§ **DEPLOY & TRI·ªÇN KHAI**

Ch·ªçn ph∆∞∆°ng th·ª©c deploy:

1. **üì± Telegram** - G·ª≠i EXE qua bot
2. **üåê Web Download** - T·∫°o link download
3. **üíæ Local Share** - Chia s·∫ª qua m·∫°ng n·ªôi b·ªô
4. **üì¶ Package** - ƒê√≥ng g√≥i th√†nh installer
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üì± G·ª≠i Telegram", "callback_data": "deploy_telegram"},
                    {"text": "üåê T·∫£i Web", "callback_data": "deploy_web"}
                ],
                [
                    {"text": "üíæ Chia s·∫ª N·ªôi b·ªô", "callback_data": "deploy_local"},
                    {"text": "üì¶ ƒê√≥ng g√≥i", "callback_data": "deploy_package"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_alerts(self, chat_id):
        """Hi·ªÉn th·ªã alerts."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("SELECT alert_type, message, severity, timestamp FROM alerts ORDER BY timestamp DESC LIMIT 10")
            alerts = cursor.fetchall()
            conn.close()
            
            if alerts:
                alerts_text = "üö® **ALERTS & C·∫¢NH B√ÅO**\n\n"
                for i, (alert_type, message, severity, timestamp) in enumerate(alerts, 1):
                    severity_icon = "üî¥" if severity == "high" else "üü°" if severity == "medium" else "üü¢"
                    alerts_text += f"{i}. {severity_icon} **{alert_type}**\n   {message}\n   ‚è∞ {timestamp}\n\n"
            else:
                alerts_text = "üö® **ALERTS & C·∫¢NH B√ÅO**\n\n‚úÖ Kh√¥ng c√≥ c·∫£nh b√°o n√†o"
            
            keyboard = {
                "inline_keyboard": [
                    [{"text": "üîÑ L√†m m·ªõi", "callback_data": "alerts"}],
                    [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
                ]
            }
            
            self.send_telegram_message(chat_id, alerts_text, keyboard)
            
        except Exception as e:
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_reports(self, chat_id):
        """Hi·ªÉn th·ªã reports."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Th·ªëng k√™ t·ªïng quan
            cursor.execute("SELECT COUNT(*) FROM clients")
            total_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM clients WHERE status = 'online'")
            online_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM activities")
            total_activities = cursor.fetchone()[0]
            
            conn.close()
            
            reports_text = f"""
üìä **B√ÅO C√ÅO T·ªîNG QUAN**

üè¢ **Clients:**
‚Ä¢ T·ªïng s·ªë: {total_clients}
‚Ä¢ Online: {online_clients}
‚Ä¢ Offline: {total_clients - online_clients}

üìà **Ho·∫°t ƒë·ªông:**
‚Ä¢ T·ªïng ho·∫°t ƒë·ªông: {total_activities}
‚Ä¢ T·ª∑ l·ªá online: {(online_clients/total_clients*100):.1f}% (n·∫øu c√≥ clients)

‚è∞ **C·∫≠p nh·∫≠t:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            keyboard = {
                "inline_keyboard": [
                    [{"text": "üîÑ L√†m m·ªõi", "callback_data": "reports"}],
                    [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
                ]
            }
            
            self.send_telegram_message(chat_id, reports_text, keyboard)
            
        except Exception as e:
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_settings(self, chat_id):
        """Hi·ªÉn th·ªã settings."""
        settings_text = """
‚öôÔ∏è **C√ÄI ƒê·∫∂T H·ªÜ TH·ªêNG**

üîê **B·∫£o m·∫≠t:**
‚Ä¢ M√£ h√≥a config: ‚úÖ B·∫≠t
‚Ä¢ Y√™u c·∫ßu x√°c th·ª±c: ‚úÖ B·∫≠t
‚Ä¢ Audit logging: ‚úÖ B·∫≠t

ü§ñ **Bot:**
‚Ä¢ Auto-restart: ‚úÖ B·∫≠t
‚Ä¢ Webhook: ‚úÖ B·∫≠t
‚Ä¢ Timeout: 10s

üìä **Monitoring:**
‚Ä¢ Real-time metrics: ‚úÖ B·∫≠t
‚Ä¢ Alert threshold: 80%
‚Ä¢ Log retention: 30 ng√†y
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üîß C√†i ƒë·∫∑t n√¢ng cao", "callback_data": "advanced_settings"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
            ]
        }
        
        self.send_telegram_message(chat_id, settings_text, keyboard)
    
    def show_build_runtime_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build runtime."""
        build_text = """
üõ°Ô∏è **BUILD RUNTIME CLIENT**

**Ch·ª©c nƒÉng:**
‚Ä¢ B·∫£o v·ªá XML files real-time
‚Ä¢ Template matching th√¥ng minh
‚Ä¢ Auto-restart v·ªõi Windows
‚Ä¢ Telegram alerts

**T√≠nh nƒÉng:**
‚úÖ File monitoring
‚úÖ Template protection
‚úÖ Performance tracking
‚úÖ Security logging
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üèóÔ∏è T·∫°o Runtime", "callback_data": "build_runtime_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "build_exe"}]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_build_builder_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build builder."""
        build_text = """
üèóÔ∏è **BUILD BUILDER TOOL**

**Ch·ª©c nƒÉng:**
‚Ä¢ T·∫°o EXE t·ª´ source code
‚Ä¢ Custom configuration
‚Ä¢ Template management
‚Ä¢ Deployment tools

**T√≠nh nƒÉng:**
‚úÖ GUI Builder
‚úÖ Template Editor
‚úÖ Config Manager
‚úÖ Deploy Helper
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üèóÔ∏è T·∫°o Builder", "callback_data": "build_builder_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "build_exe"}]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_build_hybrid_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build hybrid."""
        build_text = """
ü§ñ **BUILD HYBRID BOT**

**Ch·ª©c nƒÉng:**
‚Ä¢ V·ª´a b·∫£o v·ªá v·ª´a build
‚Ä¢ Multi-function bot
‚Ä¢ Admin controls
‚Ä¢ Real-time monitoring

**T√≠nh nƒÉng:**
‚úÖ XML Protection
‚úÖ EXE Builder
‚úÖ Admin Panel
‚úÖ Monitoring
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üèóÔ∏è T·∫°o Hybrid", "callback_data": "build_hybrid_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "build_exe"}]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_build_mobile_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build mobile."""
        build_text = """
üì± **BUILD MOBILE APP**

**Ch·ª©c nƒÉng:**
‚Ä¢ ·ª®ng d·ª•ng di ƒë·ªông
‚Ä¢ Cross-platform
‚Ä¢ Cloud sync
‚Ä¢ Push notifications

**T√≠nh nƒÉng:**
‚úÖ Mobile UI
‚úÖ Cloud Storage
‚úÖ Push Alerts
‚úÖ Offline Mode
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üèóÔ∏è T·∫°o Mobile", "callback_data": "build_mobile_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "build_exe"}]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_deploy_telegram_info(self, chat_id):
        """Hi·ªÉn th·ªã th√¥ng tin deploy Telegram."""
        deploy_text = """
üì± **DEPLOY QUA TELEGRAM**

**Ph∆∞∆°ng th·ª©c:**
‚Ä¢ G·ª≠i file EXE tr·ª±c ti·∫øp
‚Ä¢ Bot t·ª± ƒë·ªông ph√¢n ph·ªëi
‚Ä¢ Real-time notifications
‚Ä¢ Download tracking

**∆Øu ƒëi·ªÉm:**
‚úÖ Nhanh ch√≥ng
‚úÖ An to√†n
‚úÖ Tracking ƒë∆∞·ª£c
‚úÖ D·ªÖ s·ª≠ d·ª•ng
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üöÄ B·∫Øt ƒë·∫ßu Tri·ªÉn khai", "callback_data": "deploy_telegram_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "deploy"}]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_deploy_web_info(self, chat_id):
        """Hi·ªÉn th·ªã th√¥ng tin deploy web."""
        deploy_text = """
üåê **DEPLOY QUA WEB**

**Ph∆∞∆°ng th·ª©c:**
‚Ä¢ T·∫°o link download
‚Ä¢ Web interface
‚Ä¢ Progress tracking
‚Ä¢ Version management

**∆Øu ƒëi·ªÉm:**
‚úÖ D·ªÖ chia s·∫ª
‚úÖ Tracking chi ti·∫øt
‚úÖ Version control
‚úÖ Analytics
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üöÄ B·∫Øt ƒë·∫ßu Tri·ªÉn khai", "callback_data": "deploy_web_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "deploy"}]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_deploy_local_info(self, chat_id):
        """Hi·ªÉn th·ªã th√¥ng tin deploy local."""
        deploy_text = """
üíæ **DEPLOY LOCAL SHARE**

**Ph∆∞∆°ng th·ª©c:**
‚Ä¢ Chia s·∫ª qua m·∫°ng n·ªôi b·ªô
‚Ä¢ USB/CD/DVD
‚Ä¢ Network drive
‚Ä¢ Local server

**∆Øu ƒëi·ªÉm:**
‚úÖ Kh√¥ng c·∫ßn internet
‚úÖ B·∫£o m·∫≠t cao
‚úÖ T·ªëc ƒë·ªô nhanh
‚úÖ Ki·ªÉm so√°t ƒë∆∞·ª£c
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üöÄ B·∫Øt ƒë·∫ßu Tri·ªÉn khai", "callback_data": "deploy_local_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "deploy"}]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_deploy_package_info(self, chat_id):
        """Hi·ªÉn th·ªã th√¥ng tin deploy package."""
        deploy_text = """
üì¶ **DEPLOY PACKAGE**

**Ph∆∞∆°ng th·ª©c:**
‚Ä¢ ƒê√≥ng g√≥i th√†nh installer
‚Ä¢ Auto-update
‚Ä¢ Dependency management
‚Ä¢ Silent installation

**∆Øu ƒëi·ªÉm:**
‚úÖ Professional
‚úÖ Auto-install
‚úÖ Dependency check
‚úÖ Update system
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üöÄ B·∫Øt ƒë·∫ßu Tri·ªÉn khai", "callback_data": "deploy_package_start"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "deploy"}]
            ]
        }
        
        self.send_telegram_message(chat_id, deploy_text, keyboard)
    
    def show_advanced_settings(self, chat_id):
        """Hi·ªÉn th·ªã c√†i ƒë·∫∑t n√¢ng cao."""
        settings_text = """
üîß **C√ÄI ƒê·∫∂T N√ÇNG CAO**

**B·∫£o m·∫≠t:**
‚Ä¢ Encryption level: AES-256
‚Ä¢ Key rotation: 30 ng√†y
‚Ä¢ Audit trail: B·∫≠t
‚Ä¢ Access control: Role-based

**Performance:**
‚Ä¢ Cache size: 100MB
‚Ä¢ Thread pool: 10
‚Ä¢ Timeout: 30s
‚Ä¢ Retry: 3 l·∫ßn

**Monitoring:**
‚Ä¢ Log level: INFO
‚Ä¢ Metrics: Real-time
‚Ä¢ Alerts: Email + Telegram
‚Ä¢ Backup: Auto
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üîê C·∫•u h√¨nh B·∫£o m·∫≠t", "callback_data": "security_config"}],
                [{"text": "‚ö° C·∫•u h√¨nh Hi·ªáu su·∫•t", "callback_data": "performance_config"}],
                [{"text": "üìä C·∫•u h√¨nh Gi√°m s√°t", "callback_data": "monitoring_config"}],
                [{"text": "üîô Quay l·∫°i", "callback_data": "settings"}]
            ]
        }
        
        self.send_telegram_message(chat_id, settings_text, keyboard)
    
    def run(self):
        """Ch·∫°y bot."""
        print("üöÄ XML Protector Admin Bot ƒëang kh·ªüi ƒë·ªông...")
        
        # Kh·ªüi ƒë·ªông Telegram webhook
        self.start_telegram_webhook()
        
        # G·ª≠i th√¥ng b√°o kh·ªüi ƒë·ªông ch·ªâ v√†o group chat (kh√¥ng g·ª≠i ri√™ng cho admin)
        startup_msg = f"""
üöÄ **XML PROTECTOR ADMIN BOT ƒê√É KH·ªûI ƒê·ªòNG!**

‚è∞ **Th·ªùi gian:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
ü§ñ **Bot Token:** `{self.bot_token[:20]}...`
üë• **Admin IDs:** `{self.admin_ids}`

G·ª≠i /start ƒë·ªÉ b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng!
"""
        
        # Ch·ªâ g·ª≠i v√†o group chat, kh√¥ng g·ª≠i ri√™ng cho admin
        # for admin_id in self.admin_ids:
        #     self.send_telegram_message(admin_id, startup_msg)
        
        print("‚úÖ Admin Bot ƒë√£ s·∫µn s√†ng!")
        
        # Gi·ªØ bot ch·∫°y
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("‚èπÔ∏è Admin Bot ƒë√£ t·∫Øt (KeyboardInterrupt)")
        except Exception as e:
            print(f"‚ùå Admin Bot g·∫∑p l·ªói: {e}")

class XMLProtectorBuilder:
    """GUI Builder t√≠ch h·ª£p ho√†n ch·ªânh v·ªõi qu·∫£n l√Ω doanh nghi·ªáp."""
    
    def __init__(self):
        self.config = SECURE_CONFIG_TEMPLATE.copy()
        self.admin_bot = None
        self.admin_bot_thread = None
        self.security_manager = SecurityManager() if SecurityManager else None
        self.config_manager = ConfigManager() if ConfigManager else None
        self.companies_data = {}  # L∆∞u tr·ªØ th√¥ng tin t·∫•t c·∫£ doanh nghi·ªáp
        
        # Kh·ªüi t·∫°o Enterprise Manager
        self.enterprise_manager = None
        self.enterprises = {}
        self.load_enterprises()
        
        # Kh·ªüi t·∫°o GUI
        self.setup_gui()
        self.load_secure_config()
    
        print("üîê XML Protector Builder - Secure Enterprise Edition")
        print("‚úÖ GUI Builder ƒë√£ s·∫µn s√†ng v·ªõi h·ªá th·ªëng b·∫£o m·∫≠t n√¢ng cao!")
        
        # Kh·ªüi t·∫°o Enterprise Manager
        self.init_enterprise_manager()
    
    def setup_gui(self):
        """Thi·∫øt l·∫≠p giao di·ªán - T·∫§T C·∫¢ TRONG 1 TAB DUY NH·∫§T."""
        # T·∫°o c·ª≠a s·ªï ch√≠nh
        self.root = tk.Tk()
        self.root.title("üèóÔ∏è XML Protector - GUI Builder T√≠ch H·ª£p")
        self.root.geometry("1200x900")
        
        # T·∫°o canvas c√≥ th·ªÉ cu·ªôn ƒë∆∞·ª£c
        self.canvas = tk.Canvas(self.root)
        self.scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        # Pack canvas v√† scrollbar
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")
        
        # Bind mouse wheel
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # T·∫°o 1 tab duy nh·∫•t ch·ª©a t·∫•t c·∫£
        self.setup_unified_tab()
        
    def _on_mousewheel(self, event):
        """X·ª≠ l√Ω cu·ªôn chu·ªôt."""
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    def setup_unified_tab(self):
        """Tab duy nh·∫•t ch·ª©a T·∫§T C·∫¢ ch·ª©c nƒÉng."""
        # T·∫°o frame ch√≠nh v·ªõi scrollbar
        main_frame = ttk.Frame(self.scrollable_frame)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # === PH·∫¶N 1: C·∫§U H√åNH TELEGRAM ===
        telegram_frame = ttk.LabelFrame(main_frame, text="üì± C·∫•u H√¨nh Telegram Bot", padding=10)
        telegram_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(telegram_frame, text="Bot Token:").grid(row=0, column=0, sticky='w', pady=2)
        self.bot_token_entry = ttk.Entry(telegram_frame, width=60)
        self.bot_token_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(telegram_frame, text="Chat ID:").grid(row=1, column=0, sticky='w', pady=2)
        self.chat_id_entry = ttk.Entry(telegram_frame, width=60)
        self.chat_id_entry.grid(row=1, column=1, padx=5, pady=2)
        
        ttk.Label(telegram_frame, text="Admin IDs:").grid(row=2, column=0, sticky='w', pady=2)
        self.admin_ids_entry = ttk.Entry(telegram_frame, width=60)
        self.admin_ids_entry.grid(row=2, column=1, padx=5, pady=2)
        ttk.Label(telegram_frame, text="(ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y)").grid(row=2, column=2, sticky='w', pady=2)
    
        # N√∫t l∆∞u config
        save_config_btn = ttk.Button(telegram_frame, text="üíæ L∆∞u C·∫•u H√¨nh", command=self.save_secure_config)
        save_config_btn.grid(row=2, column=3, padx=5, pady=2)
        
        # === PH·∫¶N 2: QU·∫¢N L√ù DOANH NGHI·ªÜP ===
        company_frame = ttk.LabelFrame(main_frame, text="üè¢ Qu·∫£n L√Ω Doanh Nghi·ªáp", padding=10)
        company_frame.pack(fill='x', padx=5, pady=5)
        
        # Add company section
        add_company_frame = ttk.Frame(company_frame)
        add_company_frame.pack(fill='x', pady=5)
        
        ttk.Label(add_company_frame, text="MST:").grid(row=0, column=0, sticky='w', pady=2)
        self.company_mst_entry = ttk.Entry(add_company_frame, width=20)
        self.company_mst_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(add_company_frame, text="T√™n DN:").grid(row=0, column=2, sticky='w', pady=2, padx=(10,0))
        self.company_name_entry = ttk.Entry(add_company_frame, width=30)
        self.company_name_entry.grid(row=0, column=3, padx=5, pady=2)
        
        ttk.Label(add_company_frame, text="EXE Name:").grid(row=0, column=4, sticky='w', pady=2, padx=(10,0))
        self.company_exe_entry = ttk.Entry(add_company_frame, width=25)
        self.company_exe_entry.grid(row=0, column=5, padx=5, pady=2)
        
        add_company_btn = ttk.Button(add_company_frame, text="‚ûï Th√™m DN", command=self.add_company)
        add_company_btn.grid(row=0, column=6, padx=10, pady=2)
        
        # Companies list
        companies_list_frame = ttk.LabelFrame(company_frame, text="üìã Danh S√°ch Doanh Nghi·ªáp", padding=10)
        companies_list_frame.pack(fill='both', expand=True, pady=5)
        
        # Treeview for companies
        company_columns = ('MST', 'T√™n DN', 'EXE Name', 'Status', 'Templates', 'Last Deploy', 'Actions')
        self.companies_tree = ttk.Treeview(companies_list_frame, columns=company_columns, show='headings', height=8)
        
        for col in company_columns:
            self.companies_tree.heading(col, text=col)
            if col == 'MST':
                self.companies_tree.column(col, width=120)
            elif col == 'T√™n DN':
                self.companies_tree.column(col, width=200)
            elif col == 'EXE Name':
                self.companies_tree.column(col, width=180)
            elif col == 'Status':
                self.companies_tree.column(col, width=80)
            elif col == 'Templates':
                self.companies_tree.column(col, width=80)
            elif col == 'Last Deploy':
                self.companies_tree.column(col, width=120)
            else:
                self.companies_tree.column(col, width=100)
        
        # Scrollbar for companies tree
        companies_scrollbar = ttk.Scrollbar(companies_list_frame, orient='vertical', command=self.companies_tree.yview)
        self.companies_tree.configure(yscrollcommand=companies_scrollbar.set)
        
        self.companies_tree.pack(side='left', fill='both', expand=True)
        companies_scrollbar.pack(side='right', fill='y')
        
        # Company actions
        company_actions_frame = ttk.Frame(company_frame)
        company_actions_frame.pack(fill='x', pady=5)
        
        select_company_btn = ttk.Button(company_actions_frame, text="‚úÖ Ch·ªçn DN", command=self.select_company_for_build)
        select_company_btn.pack(side='left', padx=5)
        
        edit_company_btn = ttk.Button(company_actions_frame, text="‚úèÔ∏è S·ª≠a DN", command=self.edit_selected_company)
        edit_company_btn.pack(side='left', padx=5)
        
        delete_company_btn = ttk.Button(company_actions_frame, text="üóëÔ∏è X√≥a DN", command=self.delete_selected_company)
        delete_company_btn.pack(side='left', padx=5)
        
        refresh_companies_btn = ttk.Button(company_actions_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_companies_list)
        refresh_companies_btn.pack(side='left', padx=5)
        
        export_companies_btn = ttk.Button(company_actions_frame, text="üì§ Export DN", command=self.export_companies_list)
        export_companies_btn.pack(side='left', padx=5)
        
        # Selected company info
        self.selected_company_label = ttk.Label(company_actions_frame, text="üìå Ch∆∞a ch·ªçn doanh nghi·ªáp n√†o", foreground="blue")
        self.selected_company_label.pack(side='right', padx=10)
        
        # === PH·∫¶N 2.5: ENTERPRISE MANAGER - QU·∫¢N L√ù TH√îNG MINH ===
        enterprise_frame = ttk.LabelFrame(main_frame, text="üè¢ Enterprise Manager - Qu·∫£n L√Ω Th√¥ng Minh", padding=10)
        enterprise_frame.pack(fill='x', padx=5, pady=5)
        
        # Th√¥ng tin t·ªïng quan th√¥ng minh
        smart_info_frame = ttk.Frame(enterprise_frame)
        smart_info_frame.pack(fill='x', pady=5)
        
        self.smart_status_label = ttk.Label(smart_info_frame, text="üîç ƒêang ph√¢n t√≠ch XML ƒë·ªÉ ph√°t hi·ªán doanh nghi·ªáp...", 
                                           font=('Arial', 10, 'bold'), foreground="blue")
        self.smart_status_label.pack(anchor='w')
        
        # N√∫t ƒëi·ªÅu khi·ªÉn th√¥ng minh
        smart_controls_frame = ttk.Frame(enterprise_frame)
        smart_controls_frame.pack(fill='x', pady=5)
        
        # N√∫t t·ª± ƒë·ªông ph√°t hi·ªán v√† c·∫≠p nh·∫≠t
        auto_detect_btn = ttk.Button(smart_controls_frame, text="üîç T·ª± ƒê·ªông Ph√°t Hi·ªán & Ph√¢n Lo·∫°i DN", 
                                    command=self.auto_detect_enterprises_from_xml)
        auto_detect_btn.pack(side='left', padx=5)
        
        # N√∫t l√†m m·ªõi th√¥ng minh
        smart_refresh_btn = ttk.Button(smart_controls_frame, text="üîÑ L√†m M·ªõi Th√¥ng Minh", 
                                      command=self.smart_refresh_enterprises)
        smart_refresh_btn.pack(side='left', padx=5)
        
        # N√∫t xem chi ti·∫øt XML
        xml_details_btn = ttk.Button(smart_controls_frame, text="üìÑ Xem Chi Ti·∫øt XML", 
                                    command=self.show_xml_enterprise_details)
        xml_details_btn.pack(side='left', padx=5)
        
        # N√∫t h√†nh ƒë·ªông h√†ng lo·∫°t
        batch_actions_frame = ttk.Frame(enterprise_frame)
        batch_actions_frame.pack(fill='x', pady=5)
        
        build_all_btn = ttk.Button(batch_actions_frame, text="üî® Build T·∫•t C·∫£ DN Pending", 
                                  command=self.build_all_pending_enterprises)
        build_all_btn.pack(side='left', padx=5)
        
        deploy_all_btn = ttk.Button(batch_actions_frame, text="üöÄ Deploy T·∫•t C·∫£ DN Built", 
                                   command=self.deploy_all_built_enterprises)
        deploy_all_btn.pack(side='left', padx=5)
        
        # Th·ªëng k√™ th√¥ng minh
        smart_stats_frame = ttk.Frame(enterprise_frame)
        smart_stats_frame.pack(fill='x', pady=5)
        
        self.enterprises_stats_label = ttk.Label(smart_stats_frame, text="üìä Th·ªëng k√™: 0 doanh nghi·ªáp", 
                                               font=('Arial', 10, 'bold'))
        self.enterprises_stats_label.pack(side='left')
        
        # Th√¥ng tin XML ƒë∆∞·ª£c ph√°t hi·ªán
        self.xml_detection_label = ttk.Label(smart_stats_frame, text=" | üìÑ XML: 0 files", 
                                            font=('Arial', 9), foreground="green")
        self.xml_detection_label.pack(side='left', padx=10)
        
        # Danh s√°ch doanh nghi·ªáp th√¥ng minh
        enterprises_list_label = ttk.Label(enterprise_frame, text="üìã Danh S√°ch Doanh Nghi·ªáp (T·ª± ƒê·ªông Ph√°t Hi·ªán):", 
                                         font=('Arial', 10, 'bold'))
        enterprises_list_label.pack(anchor='w', pady=5)
        
        # Frame ch·ª©a danh s√°ch doanh nghi·ªáp v·ªõi giao di·ªán th√¥ng minh
        self.enterprises_list_frame = ttk.Frame(enterprise_frame)
        self.enterprises_list_frame.pack(fill='x', pady=5)
        
        # Th√¥ng b√°o khi ch∆∞a c√≥ doanh nghi·ªáp
        self.no_enterprises_label = ttk.Label(self.enterprises_list_frame, 
                                             text="üí° Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë∆∞·ª£c ph√°t hi·ªán.\nNh·∫•n 'T·ª± ƒê·ªông Ph√°t Hi·ªán & Ph√¢n Lo·∫°i DN' ƒë·ªÉ b·∫Øt ƒë·∫ßu!", 
                                             font=('Arial', 10), foreground="gray", justify='center')
        self.no_enterprises_label.pack(pady=20)
        
        # === PH·∫¶N 3: CH·ªåN XML G·ªêC ===
        xml_frame = ttk.LabelFrame(main_frame, text="üìÑ Ch·ªçn XML G·ªëc", padding=10)
        xml_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(xml_frame, text="Th∆∞ m·ª•c XML g·ªëc:").grid(row=0, column=0, sticky='w', pady=2)
        self.templates_folder_entry = ttk.Entry(xml_frame, width=70)
        self.templates_folder_entry.grid(row=0, column=1, padx=5, pady=2)
        
        browse_btn = ttk.Button(xml_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_templates_folder)
        browse_btn.grid(row=0, column=2, padx=5, pady=2)
        
        # Danh s√°ch XML
        list_frame = ttk.LabelFrame(xml_frame, text="üìã Danh S√°ch XML G·ªëc", padding=10)
        list_frame.grid(row=1, column=0, columnspan=3, sticky='ew', padx=5, pady=5)
        
        # Treeview cho XML files
        columns = ('T√™n File', 'K√≠ch Th∆∞·ªõc', 'Ng√†y T·∫°o', 'Tr·∫°ng Th√°i')
        self.xml_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=8)
        
        for col in columns:
            self.xml_tree.heading(col, text=col)
            if col == 'T√™n File':
                self.xml_tree.column(col, width=300)
            elif col == 'K√≠ch Th∆∞·ªõc':
                self.xml_tree.column(col, width=100)
            elif col == 'Ng√†y T·∫°o':
                self.xml_tree.column(col, width=150)
            else:
                self.xml_tree.column(col, width=100)
        
        self.xml_tree.pack(fill='x')
        
        # Th√¥ng tin t·ªïng quan
        self.xml_info_label = ttk.Label(xml_frame, text="üìÇ Ch∆∞a ch·ªçn th∆∞ m·ª•c XML g·ªëc")
        self.xml_info_label.grid(row=3, column=0, columnspan=3, pady=5, sticky='w')
        
        # N√∫t ph√¢n t√≠ch v√† l√†m m·ªõi
        xml_buttons_frame = ttk.Frame(xml_frame)
        xml_buttons_frame.grid(row=2, column=0, columnspan=3, pady=5, sticky='w')
        
        analyze_btn = ttk.Button(xml_buttons_frame, text="üîç Ph√¢n T√≠ch Nhanh", command=self.quick_analyze_xml)
        analyze_btn.pack(side='left', padx=5)
        
        refresh_btn = ttk.Button(xml_buttons_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_xml_list)
        refresh_btn.pack(side='left', padx=5)
        
        # === PH·∫¶N 3: C√ÄI ƒê·∫∂T BUILD ===
        build_frame = ttk.LabelFrame(main_frame, text="‚öôÔ∏è C√†i ƒê·∫∑t Build", padding=10)
        build_frame.pack(fill='x', padx=5, pady=5)
        
        # Build options
        options_frame = ttk.Frame(build_frame)
        options_frame.pack(fill='x', pady=5)
        
        self.auto_send_var = tk.BooleanVar(value=True)
        auto_send_cb = ttk.Checkbutton(options_frame, text="üì§ T·ª± ƒë·ªông g·ª≠i EXE l√™n Telegram", 
                                      variable=self.auto_send_var)
        auto_send_cb.grid(row=0, column=0, sticky='w', pady=2)
        
        self.include_guardian_var = tk.BooleanVar(value=True)
        guardian_cb = ttk.Checkbutton(options_frame, text="üõ°Ô∏è Bao g·ªìm Guardian Protection", 
                                     variable=self.include_guardian_var)
        guardian_cb.grid(row=0, column=1, sticky='w', pady=2)
        
        self.include_admin_bot_var = tk.BooleanVar(value=True)
        admin_bot_cb = ttk.Checkbutton(options_frame, text="ü§ñ Bao g·ªìm Admin Bot t√≠ch h·ª£p", 
                                      variable=self.include_admin_bot_var)
        admin_bot_cb.grid(row=1, column=0, sticky='w', pady=2)
        
        self.auto_startup_var = tk.BooleanVar(value=True)
        startup_cb = ttk.Checkbutton(options_frame, text="üöÄ T·ª± ƒë·ªông kh·ªüi ƒë·ªông c√πng Windows", 
                                    variable=self.auto_startup_var)
        startup_cb.grid(row=1, column=1, sticky='w', pady=2)
        
        # Output settings
        output_frame = ttk.Frame(build_frame)
        output_frame.pack(fill='x', pady=5)
        
        ttk.Label(output_frame, text="T√™n file EXE:").grid(row=0, column=0, sticky='w', pady=2)
        self.exe_name_entry = ttk.Entry(output_frame, width=30)
        self.exe_name_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(output_frame, text="V·ªã tr√≠ ƒë·∫ßu ra:").grid(row=1, column=0, sticky='w', pady=2)
        self.output_path_entry = ttk.Entry(output_frame, width=50)
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=2)
        
        browse_output_btn = ttk.Button(output_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_output_path)
        browse_output_btn.grid(row=1, column=2, padx=5, pady=2)
        
        # === PH·∫¶N 4: BUILD & DEPLOY ===
        build_deploy_frame = ttk.LabelFrame(main_frame, text="üèóÔ∏è Build & Deploy", padding=10)
        build_deploy_frame.pack(fill='x', padx=5, pady=5)
        
        # Build section
        build_section = ttk.Frame(build_deploy_frame)
        build_section.pack(fill='x', pady=5)
        
        build_btn = ttk.Button(build_section, text="üèóÔ∏è Build EXE Ho√†n Ch·ªânh", 
                              command=self.build_complete_exe)
        build_btn.pack(side='left', padx=5)
        
        # Progress
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(build_section, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(side='left', fill='x', expand=True, padx=5)
        
        self.build_status_label = ttk.Label(build_section, text="‚úÖ S·∫µn s√†ng build")
        self.build_status_label.pack(side='left', padx=5)
        
        # Deploy section
        deploy_section = ttk.Frame(build_deploy_frame)
        deploy_section.pack(fill='x', pady=5)
        
        deploy_btn = ttk.Button(deploy_section, text="üì§ G·ª≠i EXE l√™n Telegram", 
                               command=self.deploy_to_telegram)
        deploy_btn.pack(side='left', padx=5)
        
        download_btn = ttk.Button(deploy_section, text="üåê T·∫°o Link Download", 
                                 command=self.create_download_link)
        download_btn.pack(side='left', padx=5)
        
        # === PH·∫¶N 5: ADMIN BOT & STATUS ===
        admin_status_frame = ttk.LabelFrame(main_frame, text="ü§ñ Admin Bot & Tr·∫°ng Th√°i", padding=10)
        admin_status_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Bot controls
        controls_frame = ttk.Frame(admin_status_frame)
        controls_frame.pack(fill='x', pady=5)
        
        start_bot_btn = ttk.Button(controls_frame, text="üöÄ Kh·ªüi ƒê·ªông Admin Bot", 
                                  command=self.start_admin_bot)
        start_bot_btn.pack(side='left', padx=5)
        
        stop_bot_btn = ttk.Button(controls_frame, text="‚èπÔ∏è D·ª´ng Admin Bot", 
                                 command=self.stop_admin_bot)
        stop_bot_btn.pack(side='left', padx=5)
        
        refresh_btn = ttk.Button(controls_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_status)
        refresh_btn.pack(side='left', padx=5)
        
        # Bot status
        self.bot_status_label = ttk.Label(controls_frame, text="‚ùå Bot ch∆∞a kh·ªüi ƒë·ªông")
        self.bot_status_label.pack(side='left', padx=10)
        
        # System status v√† logs
        status_logs_frame = ttk.Frame(admin_status_frame)
        status_logs_frame.pack(fill='both', expand=True, pady=5)
        
        # System status
        system_frame = ttk.LabelFrame(status_logs_frame, text="üíª Tr·∫°ng Th√°i H·ªá Th·ªëng", padding=5)
        system_frame.pack(side='left', fill='both', expand=True, padx=(0, 5))
        
        self.system_status_text = tk.Text(system_frame, height=10, width=50)
        self.system_status_text.pack(fill='both', expand=True)
        
        # Bot logs
        logs_frame = ttk.LabelFrame(status_logs_frame, text="üìã Log Ho·∫°t ƒê·ªông", padding=5)
        logs_frame.pack(side='right', fill='both', expand=True, padx=(5, 0))
        
        self.bot_logs_text = tk.Text(logs_frame, height=10, width=50)
        self.bot_logs_text.pack(fill='both', expand=True)
    
    # === C√ÅC H√ÄM C≈® ƒê√É ƒê∆Ø·ª¢C G·ªòP V√ÄO TR√äN - KH√îNG C√íN S·ª¨ D·ª§NG ===
    
    def setup_build_config_tab(self):
        """Tab c·∫•u h√¨nh build."""
        build_frame = ttk.Frame(self.notebook)
        self.notebook.add(build_frame, text="‚öôÔ∏è C√†i ƒê·∫∑t Build")
        
        # Build options
        options_frame = ttk.LabelFrame(build_frame, text="üîß T√πy Ch·ªçn Build", padding=10)
        options_frame.pack(fill='x', padx=10, pady=5)
        
        self.auto_send_var = tk.BooleanVar(value=True)
        auto_send_cb = ttk.Checkbutton(options_frame, text="üì§ T·ª± ƒë·ªông g·ª≠i EXE l√™n Telegram", 
                                      variable=self.auto_send_var)
        auto_send_cb.grid(row=0, column=0, sticky='w', pady=2)
        
        self.include_guardian_var = tk.BooleanVar(value=True)
        guardian_cb = ttk.Checkbutton(options_frame, text="üõ°Ô∏è Bao g·ªìm Guardian Protection", 
                                     variable=self.include_guardian_var)
        guardian_cb.grid(row=1, column=0, sticky='w', pady=2)
        
        self.include_admin_bot_var = tk.BooleanVar(value=True)
        admin_bot_cb = ttk.Checkbutton(options_frame, text="ü§ñ Bao g·ªìm Admin Bot t√≠ch h·ª£p", 
                                      variable=self.include_admin_bot_var)
        admin_bot_cb.grid(row=2, column=0, sticky='w', pady=2)
        
        self.auto_startup_var = tk.BooleanVar(value=True)
        startup_cb = ttk.Checkbutton(options_frame, text="üöÄ T·ª± ƒë·ªông kh·ªüi ƒë·ªông c√πng Windows", 
                                    variable=self.auto_startup_var)
        startup_cb.grid(row=3, column=0, sticky='w', pady=2)
        
        # Output settings
        output_frame = ttk.LabelFrame(build_frame, text="üì§ C√†i ƒê·∫∑t ƒê·∫ßu Ra", padding=10)
        output_frame.pack(fill='x', padx=10, pady=5)
        
        # T√™n file EXE
        ttk.Label(output_frame, text="T√™n file EXE:").grid(row=0, column=0, sticky='w', pady=2)
        self.exe_name_entry = ttk.Entry(output_frame, width=30)
        self.exe_name_entry.grid(row=0, column=1, padx=5, pady=2)
        
        # V·ªã tr√≠ ƒë·∫ßu ra
        ttk.Label(output_frame, text="V·ªã tr√≠ ƒë·∫ßu ra:").grid(row=1, column=0, sticky='w', pady=2)
        self.output_path_entry = ttk.Entry(output_frame, width=50)
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=2)
        
        browse_output_btn = ttk.Button(output_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_output_path)
        browse_output_btn.grid(row=1, column=2, padx=5, pady=2)
        
        # Ch·ªçn file EXE c·ª• th·ªÉ
        ttk.Label(output_frame, text="File EXE c·ª• th·ªÉ:").grid(row=2, column=0, sticky='w', pady=2)
        self.specific_exe_entry = ttk.Entry(output_frame, width=50)
        self.specific_exe_entry.grid(row=2, column=1, padx=5, pady=2)
        
        browse_exe_btn = ttk.Button(output_frame, text="üîç Ch·ªçn File EXE", command=self.browse_specific_exe)
        browse_exe_btn.grid(row=2, column=2, padx=5, pady=2)
        
        # N√∫t xem danh s√°ch file EXE c√≥ s·∫µn
        list_exe_btn = ttk.Button(output_frame, text="üìã Danh s√°ch File EXE", command=self.show_available_exe_files)
        list_exe_btn.grid(row=2, column=3, padx=5, pady=2)
    
    def setup_admin_bot_tab(self):
        """Tab qu·∫£n l√Ω Admin Bot."""
        admin_frame = ttk.Frame(self.notebook)
        self.notebook.add(admin_frame, text="ü§ñ Qu·∫£n L√Ω Admin Bot")
        
        # Bot controls
        controls_frame = ttk.LabelFrame(admin_frame, text="üéÆ ƒêi·ªÅu Khi·ªÉn Bot", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)
        
        start_bot_btn = ttk.Button(controls_frame, text="üöÄ Kh·ªüi ƒê·ªông Admin Bot", 
                                  command=self.start_admin_bot)
        start_bot_btn.pack(side='left', padx=5)
        
        stop_bot_btn = ttk.Button(controls_frame, text="‚èπÔ∏è D·ª´ng Admin Bot", 
                                 command=self.stop_admin_bot)
        stop_bot_btn.pack(side='left', padx=5)
        
        # Bot status
        status_frame = ttk.LabelFrame(admin_frame, text="üìä Tr·∫°ng Th√°i Bot", padding=10)
        status_frame.pack(fill='x', padx=10, pady=5)
        
        self.bot_status_label = ttk.Label(status_frame, text="‚ùå Bot ch∆∞a kh·ªüi ƒë·ªông")
        self.bot_status_label.pack()
        
        # Bot logs
        logs_frame = ttk.LabelFrame(admin_frame, text="üìã Log Ho·∫°t ƒê·ªông", padding=10)
        logs_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.bot_logs_text = tk.Text(logs_frame, height=15)
        self.bot_logs_text.pack(fill='both', expand=True)
    
    def setup_clients_tab(self):
        """Tab qu·∫£n l√Ω clients."""
        clients_frame = ttk.Frame(self.notebook)
        self.notebook.add(clients_frame, text="üñ•Ô∏è Qu·∫£n L√Ω Clients")
        
        # Client list
        list_frame = ttk.LabelFrame(clients_frame, text="üìã Danh S√°ch Clients", padding=10)
        list_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Treeview cho clients
        columns = ('T√™n Client', 'ID', 'Tr·∫°ng Th√°i', 'Templates', 'Cu·ªëi C√πng')
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show='headings')
        
        for col in columns:
            self.clients_tree.heading(col, text=col)
            self.clients_tree.column(col, width=150)
        
        self.clients_tree.pack(fill='both', expand=True)
        
        # Client actions
        actions_frame = ttk.Frame(clients_frame)
        actions_frame.pack(fill='x', padx=10, pady=5)
        
        refresh_btn = ttk.Button(actions_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_clients)
        refresh_btn.pack(side='left', padx=5)
        
        delete_btn = ttk.Button(actions_frame, text="üóëÔ∏è X√≥a Client", command=self.delete_client)
        delete_btn.pack(side='left', padx=5)
    
    def setup_build_deploy_tab(self):
        """Tab build v√† deploy."""
        build_deploy_frame = ttk.Frame(self.notebook)
        self.notebook.add(build_deploy_frame, text="üèóÔ∏è Build & Deploy")
        
        # Build section
        build_section = ttk.LabelFrame(build_deploy_frame, text="üî® T·∫°o EXE", padding=10)
        build_section.pack(fill='x', padx=10, pady=5)
        
        build_btn = ttk.Button(build_section, text="üèóÔ∏è Build EXE Ho√†n Ch·ªânh", 
                              command=self.build_complete_exe)
        build_btn.pack(pady=10)
        
        # Progress
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(build_section, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill='x', pady=5)
        
        self.build_status_label = ttk.Label(build_section, text="‚úÖ S·∫µn s√†ng build")
        self.build_status_label.pack()
        
        # Deploy section
        deploy_section = ttk.LabelFrame(build_deploy_frame, text="üì§ Tri·ªÉn Khai", padding=10)
        deploy_section.pack(fill='x', padx=10, pady=5)
        
        deploy_btn = ttk.Button(deploy_section, text="üì§ G·ª≠i EXE l√™n Telegram", 
                               command=self.deploy_to_telegram)
        deploy_btn.pack(side='left', padx=5)
        
        download_btn = ttk.Button(deploy_section, text="üåê T·∫°o Link Download", 
                                 command=self.create_download_link)
        download_btn.pack(side='left', padx=5)
    
    def setup_status_logs_tab(self):
        """Tab tr·∫°ng th√°i v√† logs."""
        status_frame = ttk.Frame(self.notebook)
        self.notebook.add(status_frame, text="üìä Tr·∫°ng Th√°i & Logs")
        
        # System status
        system_frame = ttk.LabelFrame(status_frame, text="üíª Tr·∫°ng Th√°i H·ªá Th·ªëng", padding=10)
        system_frame.pack(fill='x', padx=10, pady=5)
        
        self.system_status_text = tk.Text(system_frame, height=8)
        self.system_status_text.pack(fill='x')
        
        # Logs
        logs_frame = ttk.LabelFrame(status_frame, text="üìã Log H·ªá Th·ªëng", padding=10)
        logs_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.system_logs_text = tk.Text(logs_frame, height=15)
        self.system_logs_text.pack(fill='both', expand=True)
        
        # Refresh button
        refresh_btn = ttk.Button(status_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_status)
        refresh_btn.pack(pady=5)
    
    def browse_templates_folder(self):
        """Ch·ªçn th∆∞ m·ª•c templates."""
        folder = filedialog.askdirectory(title="Ch·ªçn th∆∞ m·ª•c ch·ª©a XML g·ªëc")
        if folder:
            self.templates_folder_entry.delete(0, 'end')
            self.templates_folder_entry.insert(0, folder)
            # T·ª± ƒë·ªông l√†m m·ªõi danh s√°ch XML
            self.refresh_xml_list()
            
            # Hi·ªÉn th·ªã th√¥ng b√°o
            xml_count = len(glob.glob(os.path.join(folder, "*.xml")))
            if xml_count > 0:
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ t√¨m th·∫•y {xml_count} file XML trong th∆∞ m·ª•c!")
            else:
                messagebox.showwarning("C·∫£nh b√°o", "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file XML n√†o trong th∆∞ m·ª•c!")
    
    def refresh_xml_list(self):
        """L√†m m·ªõi danh s√°ch XML."""
        # X√≥a d·ªØ li·ªáu c≈©
        for item in self.xml_tree.get_children():
            self.xml_tree.delete(item)
        
        folder = self.templates_folder_entry.get().strip()
        if folder and os.path.exists(folder):
            xml_files = glob.glob(os.path.join(folder, "*.xml"))
            if xml_files:
                for xml_file in xml_files:
                    try:
                        filename = Path(xml_file).name
                        size_bytes = os.path.getsize(xml_file)
                        size_kb = size_bytes / 1024
                        created_time = datetime.fromtimestamp(os.path.getctime(xml_file))
                        created_str = created_time.strftime('%Y-%m-%d %H:%M')
                        
                        # Ki·ªÉm tra tr·∫°ng th√°i file
                        if size_bytes > 0:
                            status = "‚úÖ S·∫µn s√†ng"
                        else:
                            status = "‚ùå L·ªói"
                        
                        # Th√™m v√†o treeview
                        self.xml_tree.insert('', 'end', values=(
                            filename,
                            f"{size_kb:.1f} KB",
                            created_str,
                            status
                        ))
                    
                    except Exception as e:
                        # Th√™m file l·ªói
                        self.xml_tree.insert('', 'end', values=(
                            Path(xml_file).name,
                            "L·ªói",
                            "N/A",
                            "‚ùå L·ªói"
                        ))
                
                # C·∫≠p nh·∫≠t th√¥ng tin t·ªïng quan
                total_size = sum(os.path.getsize(f) for f in xml_files)
                self.xml_info_label.configure(
                    text=f"üìä T√¨m th·∫•y {len(xml_files)} file XML | T·ªïng k√≠ch th∆∞·ªõc: {total_size/1024/1024:.2f} MB"
                )
                
                # C·∫≠p nh·∫≠t build status n·∫øu c√≥
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text=f"‚úÖ S·∫µn s√†ng build v·ªõi {len(xml_files)} file XML")
            else:
                self.xml_info_label.configure(text="‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file XML n√†o trong th∆∞ m·ª•c")
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text="‚ö†Ô∏è Kh√¥ng c√≥ file XML ƒë·ªÉ build")
        else:
            self.xml_info_label.configure(text="üìÇ Ch∆∞a ch·ªçn th∆∞ m·ª•c XML g·ªëc")
            if hasattr(self, 'build_status_label'):
                self.build_status_label.configure(text="üìÇ Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc")
    
    def start_admin_bot(self):
        """Kh·ªüi ƒë·ªông Admin Bot."""
        try:
            if not self.admin_bot:
                self.admin_bot = AdminBot(self.config)
                # Kh·ªüi ƒë·ªông webhook trong thread ri√™ng
                self.admin_bot_thread = threading.Thread(target=self.admin_bot.start_telegram_webhook, daemon=True)
                self.admin_bot_thread.start()
                
                self.bot_status_label.configure(text="üü¢ Bot ƒëang ho·∫°t ƒë·ªông")
                self.log_bot_message("üöÄ Admin Bot ƒë√£ kh·ªüi ƒë·ªông")
            else:
                messagebox.showinfo("Th√¥ng b√°o", "Admin Bot ƒë√£ ƒëang ch·∫°y!")
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông Admin Bot: {e}")
    
    def stop_admin_bot(self):
        """D·ª´ng Admin Bot."""
        try:
            if self.admin_bot:
                self.admin_bot = None
                self.bot_status_label.configure(text="‚ùå Bot ƒë√£ d·ª´ng")
                self.log_bot_message("‚èπÔ∏è Admin Bot ƒë√£ d·ª´ng")
            else:
                messagebox.showinfo("Th√¥ng b√°o", "Admin Bot ch∆∞a ch·∫°y!")
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ d·ª´ng Admin Bot: {e}")
    
    def log_bot_message(self, message):
        """Ghi log bot."""
        timestamp = datetime.now().strftime('%H:%M:%S')
        self.bot_logs_text.insert('end', f"[{timestamp}] {message}\n")
        self.bot_logs_text.see('end')
    
    def build_complete_exe(self):
        """Build EXE ho√†n ch·ªânh v·ªõi t·∫•t c·∫£ ch·ª©c nƒÉng."""
        try:
            self.build_status_label.configure(text="üèóÔ∏è ƒêang build EXE...")
            self.progress_var.set(10)
            
            # Ki·ªÉm tra PyInstaller
            try:
                subprocess.run([sys.executable, '-m', 'PyInstaller', '--version'], 
                             capture_output=True, check=True)
            except:
                messagebox.showerror("L·ªói", "PyInstaller ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t!\nCh·∫°y: pip install pyinstaller")
                return
            
            # L·∫•y th√¥ng tin build
            exe_name = self.exe_name_entry.get().strip() or "XML_Protector_Runtime.exe"
            # ƒê·∫£m b·∫£o t√™n file c√≥ ƒëu√¥i .exe
            if not exe_name.endswith('.exe'):
                exe_name += '.exe'
                
            output_path = self.output_path_entry.get().strip() or os.getcwd()
            # ƒê·∫£m b·∫£o output_path t·ªìn t·∫°i v√† l√† ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi
            output_path = os.path.abspath(output_path)
            templates_path = self.templates_folder_entry.get().strip()
            
            if not templates_path or not os.path.exists(templates_path):
                messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc tr∆∞·ªõc!")
                return
            
            # T·∫°o th∆∞ m·ª•c output
            os.makedirs(output_path, exist_ok=True)
            self.progress_var.set(20)
            
            # T·∫°o t√™n spec file (kh√¥ng c√≥ ƒëu√¥i .exe)
            exe_basename = exe_name.replace('.exe', '')
            
            # T·∫°o spec file v·ªõi ƒë∆∞·ªùng d·∫´n an to√†n
            runtime_path = os.path.join(os.getcwd(), "src", "xml_protector_runtime.py").replace("\\", "/")
            templates_path_safe = templates_path.replace("\\", "/")
            current_dir_safe = os.getcwd().replace("\\", "/")
            
            spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    [r'{runtime_path}'],
    pathex=[r'{current_dir_safe}'],
    binaries=[],
    datas=[(r'{templates_path_safe}', 'templates')],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{exe_basename}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=None
)
'''
            
            spec_file = os.path.join(output_path, f"{exe_basename}.spec")
            with open(spec_file, 'w', encoding='utf-8') as f:
                f.write(spec_content)
            
            self.progress_var.set(40)
            
            # Build EXE v·ªõi PyInstaller
            build_cmd = [sys.executable, '-m', 'PyInstaller', '--clean', spec_file]
            
            # Ch·∫°y PyInstaller t·ª´ th∆∞ m·ª•c d·ª± √°n (ƒë·ªÉ t√¨m ƒë∆∞·ª£c src/xml_protector_runtime.py)
            current_dir = os.getcwd()
            result = subprocess.run(build_cmd, cwd=current_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.progress_var.set(100)
                self.build_status_label.configure(text="‚úÖ Build EXE th√†nh c√¥ng!")
                
                # T√¨m file EXE ƒë√£ t·∫°o (PyInstaller t·∫°o trong th∆∞ m·ª•c hi·ªán t·∫°i)
                dist_path = os.path.join(current_dir, 'dist', exe_name)
                
                # N·∫øu output_path kh√°c current_dir, move file EXE sang ƒë√≥
                if output_path != current_dir and os.path.exists(dist_path):
                    target_dist = os.path.join(output_path, 'dist')
                    os.makedirs(target_dist, exist_ok=True)
                    target_exe = os.path.join(target_dist, exe_name)
                    shutil.move(dist_path, target_exe)
                    exe_path = target_exe
                else:
                    exe_path = dist_path
                
                if os.path.exists(exe_path):
                    messagebox.showinfo("Th√†nh c√¥ng", 
                        f"EXE ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!\n\n"
                        f"üìÅ V·ªã tr√≠: {exe_path}\n"
                        f"üìä K√≠ch th∆∞·ªõc: {os.path.getsize(exe_path):,} bytes")
                else:
                    messagebox.showwarning("C·∫£nh b√°o", 
                        "EXE ƒë√£ ƒë∆∞·ª£c build nh∆∞ng kh√¥ng t√¨m th·∫•y file ƒë·∫ßu ra!")
            else:
                raise Exception(f"PyInstaller build failed: {result.stderr}")
            
        except Exception as e:
            self.build_status_label.configure(text="‚ùå Build EXE th·∫•t b·∫°i!")
            messagebox.showerror("L·ªói", f"Build EXE th·∫•t b·∫°i: {e}")
            self.progress_var.set(0)
    
    def deploy_to_telegram(self):
        """G·ª≠i EXE l√™n Telegram."""
        try:
            # T√¨m file EXE m·ªõi nh·∫•t
            exe_name = self.exe_name_entry.get().strip() or "test.exe"
            output_path = self.output_path_entry.get().strip() or "."
            
            # T√¨m file EXE v·ªõi ƒë∆∞·ªùng d·∫´n linh ho·∫°t - ∆ØU TI√äN FILE ƒê∆Ø·ª¢C CH·ªåN
            exe_file = None
            
            # 1. ∆ØU TI√äN: File EXE c·ª• th·ªÉ ƒë∆∞·ª£c ch·ªçn
            specific_exe = self.specific_exe_entry.get().strip() if hasattr(self, 'specific_exe_entry') else ""
            if specific_exe and Path(specific_exe).exists():
                exe_file = Path(specific_exe)
                print(f"‚úÖ S·ª≠ d·ª•ng file EXE ƒë∆∞·ª£c ch·ªçn: {exe_file}")
            else:
                # 2. T√¨m file EXE v·ªõi ƒë∆∞·ªùng d·∫´n linh ho·∫°t
                possible_paths = []
                
                # Th∆∞ m·ª•c output ƒë∆∞·ª£c ch·ªçn
                if output_path and output_path != ".":
                    possible_paths.extend([
                        Path(output_path) / exe_name,
                        Path(output_path) / "dist" / exe_name,
                        Path(output_path) / "build" / exe_name
                    ])
                
                # Th∆∞ m·ª•c hi·ªán t·∫°i v√† c√°c th∆∞ m·ª•c con
                current_dir = Path.cwd()
                possible_paths.extend([
                    current_dir / exe_name,
                    current_dir / "dist" / exe_name,
                    current_dir / "build" / exe_name,
                    current_dir / "output" / exe_name
                ])
                
                # Th∆∞ m·ª•c project (n·∫øu kh√°c th∆∞ m·ª•c hi·ªán t·∫°i)
                project_dir = Path(__file__).parent.parent
                if project_dir != current_dir:
                    possible_paths.extend([
                        project_dir / exe_name,
                        project_dir / "dist" / exe_name,
                        project_dir / "build" / exe_name
                    ])
                
                # T√¨m file .exe b·∫•t k·ª≥ trong c√°c th∆∞ m·ª•c dist/build
                for base_dir in [current_dir, project_dir]:
                    for subdir in ["dist", "build", "output"]:
                        subdir_path = base_dir / subdir
                        if subdir_path.exists():
                            exe_files = list(subdir_path.glob("*.exe"))
                            if exe_files:
                                possible_paths.extend(exe_files)
                
                print(f"üîç T√¨m file EXE v·ªõi ƒë∆∞·ªùng d·∫´n linh ho·∫°t:")
                print(f"üìÅ Th∆∞ m·ª•c hi·ªán t·∫°i: {current_dir}")
                print(f"üìÅ Th∆∞ m·ª•c project: {project_dir}")
                print(f"üîç C√°c ƒë∆∞·ªùng d·∫´n c√≥ th·ªÉ: {[str(p) for p in possible_paths]}")
                
                # T√¨m file ƒë·∫ßu ti√™n t·ªìn t·∫°i
                for path in possible_paths:
                    if path.exists():
                        exe_file = path
                        print(f"‚úÖ T√¨m th·∫•y file EXE: {exe_file}")
                        break
            
            if not exe_file:
                # N·∫øu kh√¥ng t√¨m th·∫•y, hi·ªÉn th·ªã t·∫•t c·∫£ file .exe c√≥ s·∫µn
                all_exe_files = []
                for base_dir in [current_dir, project_dir]:
                    for subdir in ["dist", "build", "output"]:
                        subdir_path = base_dir / subdir
                        if subdir_path.exists():
                            exe_files = list(subdir_path.glob("*.exe"))
                            all_exe_files.extend(exe_files)
                
                if all_exe_files:
                    exe_list = "\n".join([f"‚Ä¢ {f}" for f in all_exe_files])
                    messagebox.showerror("L·ªói", 
                        f"Kh√¥ng t√¨m th·∫•y file '{exe_name}'!\n\n"
                        f"C√°c file EXE c√≥ s·∫µn:\n{exe_list}\n\n"
                        f"Vui l√≤ng ki·ªÉm tra t√™n file ho·∫∑c ch·ªçn file kh√°c!")
                else:
                    messagebox.showerror("L·ªói", 
                        f"Kh√¥ng t√¨m th·∫•y file EXE n√†o!\n\n"
                        f"ƒê√£ t√¨m trong:\n"
                        f"‚Ä¢ {current_dir}\n"
                        f"‚Ä¢ {project_dir}\n"
                        f"‚Ä¢ C√°c th∆∞ m·ª•c: dist, build, output")
                return
            
            if not exe_file.exists():
                messagebox.showerror("L·ªói", f"Kh√¥ng t√¨m th·∫•y file EXE: {exe_file}")
                return
            
            # Ki·ªÉm tra k√≠ch th∆∞·ªõc file (Telegram limit 50MB)
            file_size = exe_file.stat().st_size
            if file_size > 50 * 1024 * 1024:  # 50MB
                messagebox.showerror("L·ªói", f"File EXE qu√° l·ªõn ({file_size/(1024*1024):.1f}MB). Telegram ch·ªâ h·ªó tr·ª£ t·ªëi ƒëa 50MB!")
                return
            
            # Chu·∫©n b·ªã th√¥ng tin
            bot_token = self.bot_token_entry.get().strip()
            chat_id = self.chat_id_entry.get().strip()
            
            if not bot_token or not chat_id:
                messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p Bot Token v√† Chat ID!")
                return
            
            # Hi·ªÉn th·ªã ti·∫øn tr√¨nh
            if hasattr(self, 'build_status_label'):
                self.build_status_label.configure(text="üì§ ƒêang g·ª≠i EXE l√™n Telegram...")
            if hasattr(self, 'progress_var'):
                self.progress_var.set(50)
            
            # G·ª≠i file
            url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
            
            with open(exe_file, 'rb') as f:
                files = {'document': f}
                data = {
                    'chat_id': chat_id,
                    'caption': f"""
üèóÔ∏è **XML PROTECTOR EXE M·ªöI**

üìÑ **File:** `{exe_name}`
üì¶ **K√≠ch th∆∞·ªõc:** `{file_size/(1024*1024):.1f}MB`
üïê **Build time:** `{time.strftime('%Y-%m-%d %H:%M:%S')}`
üíª **Build b·ªüi:** XML Protector Builder

‚úÖ S·∫µn s√†ng tri·ªÉn khai!
""",
                    'parse_mode': 'Markdown'
                }
                
                # S·ª≠a l·ªói SSL v·ªõi Telegram API - S·ª≠ d·ª•ng session v·ªõi SSL config
                import urllib3
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                
                # T·∫°o session v·ªõi SSL config t·ªëi ∆∞u
                session = requests.Session()
                session.verify = False
                session.trust_env = False
                
                # Th·ª≠ g·ª≠i v·ªõi session ƒë√£ config - c·∫£i thi·ªán SSL handling
                response = None
                try:
                    print("üîÑ Th·ª≠ g·ª≠i v·ªõi SSL config t·ªëi ∆∞u...")
                    response = session.post(url, files=files, data=data, timeout=300)
                    print(f"‚úÖ G·ª≠i Telegram th√†nh c√¥ng v·ªõi SSL config t·ªëi ∆∞u")
                except Exception as ssl_error:
                    print(f"‚ö†Ô∏è L·ªói SSL, th·ª≠ fallback: {ssl_error}")
                    try:
                        # Fallback 1: requests v·ªõi verify=False
                        print("üîÑ Th·ª≠ fallback v·ªõi verify=False...")
                        response = requests.post(url, files=files, data=data, timeout=300, verify=False)
                        print(f"‚úÖ G·ª≠i Telegram th√†nh c√¥ng v·ªõi fallback")
                    except Exception as fallback_error:
                        print(f"‚ùå Fallback c≈©ng th·∫•t b·∫°i: {fallback_error}")
                        # Fallback 2: th·ª≠ v·ªõi timeout ng·∫Øn h∆°n
                        try:
                            print("üîÑ Th·ª≠ fallback v·ªõi timeout ng·∫Øn...")
                            response = requests.post(url, files=files, data=data, timeout=60, verify=False)
                            print(f"‚úÖ G·ª≠i Telegram th√†nh c√¥ng v·ªõi timeout ng·∫Øn")
                        except Exception as final_error:
                            print(f"‚ùå T·∫•t c·∫£ fallback ƒë·ªÅu th·∫•t b·∫°i: {final_error}")
                            raise final_error
            
            if response and response.status_code == 200:
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text="‚úÖ ƒê√£ g·ª≠i EXE l√™n Telegram th√†nh c√¥ng!")
                if hasattr(self, 'progress_var'):
                    self.progress_var.set(100)
                messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ g·ª≠i {exe_name} l√™n Telegram th√†nh c√¥ng!")
                print(f"‚úÖ File {exe_name} ƒë√£ g·ª≠i th√†nh c√¥ng l√™n Telegram!")
            else:
                if response:
                    try:
                        error_data = response.json()
                        error_msg = error_data.get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                    except:
                        error_msg = f"HTTP {response.status_code}: {response.text}"
                else:
                    error_msg = "Kh√¥ng c√≥ response t·ª´ Telegram API"
                
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text="‚ùå L·ªói g·ª≠i Telegram")
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ g·ª≠i EXE l√™n Telegram: {error_msg}")
                print(f"‚ùå L·ªói g·ª≠i Telegram: {error_msg}")
            
        except Exception as e:
            if hasattr(self, 'build_status_label'):
                self.build_status_label.configure(text="‚ùå L·ªói g·ª≠i Telegram")
            error_msg = f"L·ªói g·ª≠i EXE l√™n Telegram: {str(e)}"
            messagebox.showerror("L·ªói", error_msg)
            print(f"‚ùå Exception trong deploy_to_telegram: {e}")
            import traceback
            traceback.print_exc()
    
    def run_exe_local(self):
        """Ch·∫°y EXE v·ª´a build ra tr√™n local m√°y."""
        try:
            # T√¨m file EXE v·ªõi ƒë∆∞·ªùng d·∫´n linh ho·∫°t
            exe_name = self.exe_name_entry.get().strip() or "test.exe"
            output_path = self.output_path_entry.get().strip() or "."
            
            # T√¨m file EXE v·ªõi ƒë∆∞·ªùng d·∫´n linh ho·∫°t - KH√îNG FIX C·ª®NG
            possible_paths = []
            
            # 1. Th∆∞ m·ª•c output ƒë∆∞·ª£c ch·ªçn
            if output_path and output_path != ".":
                possible_paths.extend([
                    Path(output_path) / exe_name,
                    Path(output_path) / "dist" / exe_name,
                    Path(output_path) / "build" / exe_name
                ])
            
            # 2. Th∆∞ m·ª•c hi·ªán t·∫°i v√† c√°c th∆∞ m·ª•c con
            current_dir = Path.cwd()
            possible_paths.extend([
                current_dir / exe_name,
                current_dir / "dist" / exe_name,
                current_dir / "build" / exe_name,
                current_dir / "output" / exe_name
            ])
            
            # 3. Th∆∞ m·ª•c project (n·∫øu kh√°c th∆∞ m·ª•c hi·ªán t·∫°i)
            project_dir = Path(__file__).parent.parent
            if project_dir != current_dir:
                possible_paths.extend([
                    project_dir / exe_name,
                    project_dir / "dist" / exe_name,
                    project_dir / "build" / exe_name
                ])
            
            # 4. T√¨m file .exe b·∫•t k·ª≥ trong c√°c th∆∞ m·ª•c dist/build
            for base_dir in [current_dir, project_dir]:
                for subdir in ["dist", "build", "output"]:
                    subdir_path = base_dir / subdir
                    if subdir_path.exists():
                        exe_files = list(subdir_path.glob("*.exe"))
                        if exe_files:
                            possible_paths.extend(exe_files)
            
            print(f"üîç T√¨m file EXE ƒë·ªÉ ch·∫°y local:")
            print(f"üîç C√°c ƒë∆∞·ªùng d·∫´n c√≥ th·ªÉ: {[str(p) for p in possible_paths]}")
            
            # T√¨m file ƒë·∫ßu ti√™n t·ªìn t·∫°i
            exe_file = None
            for path in possible_paths:
                if path.exists():
                    exe_file = path
                    print(f"‚úÖ T√¨m th·∫•y file EXE ƒë·ªÉ ch·∫°y: {exe_file}")
                    break
            
            if not exe_file:
                messagebox.showerror("L·ªói", f"Kh√¥ng t√¨m th·∫•y file EXE '{exe_name}' ƒë·ªÉ ch·∫°y!")
                return
            
            # Ki·ªÉm tra file c√≥ th·ªÉ ch·∫°y ƒë∆∞·ª£c kh√¥ng
            if not os.access(exe_file, os.X_OK):
                messagebox.showerror("L·ªói", f"File {exe_file} kh√¥ng th·ªÉ ch·∫°y ƒë∆∞·ª£c!")
                return
            
            # Hi·ªÉn th·ªã th√¥ng b√°o
            result = messagebox.askyesno(
                "X√°c nh·∫≠n ch·∫°y EXE", 
                f"B·∫°n c√≥ mu·ªën ch·∫°y file EXE n√†y kh√¥ng?\n\n"
                f"üìÅ File: {exe_file.name}\n"
                f"üìç ƒê∆∞·ªùng d·∫´n: {exe_file}\n"
                f"üì¶ K√≠ch th∆∞·ªõc: {exe_file.stat().st_size / (1024*1024):.1f} MB\n\n"
                f"‚ö†Ô∏è L∆∞u √Ω: EXE s·∫Ω ch·∫°y song song v·ªõi Admin Bot!"
            )
            
            if result:
                try:
                    # Ch·∫°y EXE trong background
                    import subprocess
                    process = subprocess.Popen(
                        [str(exe_file)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        creationflags=subprocess.CREATE_NEW_CONSOLE
                    )
                    
                    print(f"üöÄ ƒê√£ kh·ªüi ƒë·ªông EXE: {exe_file}")
                    print(f"üìä Process ID: {process.pid}")
                    
                    # C·∫≠p nh·∫≠t status
                    if hasattr(self, 'build_status_label'):
                        self.build_status_label.configure(text=f"üöÄ ƒêang ch·∫°y EXE: {exe_file.name}")
                    
                    messagebox.showinfo(
                        "Th√†nh c√¥ng", 
                        f"‚úÖ ƒê√£ kh·ªüi ƒë·ªông EXE th√†nh c√¥ng!\n\n"
                        f"üìÅ File: {exe_file.name}\n"
                        f"üìä Process ID: {process.pid}\n\n"
                        f"üí° EXE ƒëang ch·∫°y song song v·ªõi Admin Bot!\n"
                        f"üì± Ki·ªÉm tra Telegram ƒë·ªÉ xem log kh·ªüi ƒë·ªông!"
                    )
                    
                    # G·ª≠i th√¥ng b√°o l√™n Telegram
                    try:
                        if hasattr(self, 'admin_bot') and self.admin_bot:
                            self.admin_bot.send_telegram_message(
                                self.admin_bot.group_id,
                                f"üöÄ **EXE ƒê√É ƒê∆Ø·ª¢C KH·ªûI ƒê·ªòNG LOCAL!**\n\n"
                                f"üìÅ **File:** `{exe_file.name}`\n"
                                f"üìç **ƒê∆∞·ªùng d·∫´n:** `{exe_file}`\n"
                                f"üìä **Process ID:** `{process.pid}`\n"
                                f"üïê **Th·ªùi gian:** `{time.strftime('%Y-%m-%d %H:%M:%S')}`\n\n"
                                f"‚úÖ **Tr·∫°ng th√°i:** ƒêang ch·∫°y song song v·ªõi Admin Bot!\n"
                                f"üì± **Log:** S·∫Ω nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o khi EXE kh·ªüi ƒë·ªông!"
                            )
                    except Exception as telegram_error:
                        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o Telegram: {telegram_error}")
                    
                except Exception as run_error:
                    print(f"‚ùå L·ªói ch·∫°y EXE: {run_error}")
                    messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ch·∫°y EXE: {run_error}")
            
        except Exception as e:
            print(f"‚ùå Exception trong run_exe_local: {e}")
            messagebox.showerror("L·ªói", f"L·ªói ch·∫°y EXE local: {e}")
    
    def create_download_link(self):
        """T·∫°o link download."""
        try:
            # T√¨m file EXE
            exe_name = self.exe_name_entry.get().strip() or "quang_ninh.exe"
            output_path = self.output_path_entry.get().strip() or "."
            
            exe_file = Path(output_path) / "dist" / exe_name
            
            if not exe_file.exists():
                messagebox.showerror("L·ªói", f"Kh√¥ng t√¨m th·∫•y file EXE: {exe_file}")
                return
            
            # T·∫°o th∆∞ m·ª•c share n·∫øu ch∆∞a c√≥
            share_dir = Path("shared_files")
            share_dir.mkdir(exist_ok=True)
            
            # Copy file EXE v√†o th∆∞ m·ª•c share
            shared_exe = share_dir / exe_name
            shutil.copy2(exe_file, shared_exe)
            
            # T·∫°o link download local
            download_link = f"file:///{shared_exe.absolute()}"
            
            # Hi·ªÉn th·ªã th√¥ng tin
            file_size = shared_exe.stat().st_size
            link_info = f"""
üì• **LINK DOWNLOAD ƒê√É T·∫†O**

üìÑ **File:** {exe_name}
üì¶ **K√≠ch th∆∞·ªõc:** {file_size/(1024*1024):.1f}MB
üìÇ **V·ªã tr√≠:** {shared_exe.absolute()}
üîó **Link Local:** {download_link}

üí° **H∆∞·ªõng d·∫´n:**
1. File ƒë√£ ƒë∆∞·ª£c copy v√†o th∆∞ m·ª•c 'shared_files'
2. C√≥ th·ªÉ chia s·∫ª file n√†y qua:
   - USB/CD/DVD
   - Email (n·∫øu file nh·ªè)
   - Cloud storage (Google Drive, OneDrive...)
   - Local network share

‚úÖ File s·∫µn s√†ng chia s·∫ª!
"""
            
            messagebox.showinfo("Link Download", link_info)
            
            # M·ªü th∆∞ m·ª•c ch·ª©a file
            import subprocess
            subprocess.run(['explorer', str(share_dir.absolute())], shell=True)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫°o link download: {e}")
    
    def refresh_clients(self):
        """L√†m m·ªõi danh s√°ch clients."""
        # TODO: Implement refresh clients
        pass
    
    def delete_client(self):
        """X√≥a client."""
        # TODO: Implement delete client
        pass
    
    def refresh_status(self):
        """L√†m m·ªõi tr·∫°ng th√°i h·ªá th·ªëng."""
        try:
            # System info
            # T√°ch logic ph·ª©c t·∫°p ra
            bot_status = 'üü¢ ƒêang ch·∫°y' if self.admin_bot else 'üî¥ ƒê√£ d·ª´ng'
            templates_count = len(glob.glob(os.path.join(self.templates_folder_entry.get(), '*.xml'))) if self.templates_folder_entry.get() else 0
            
            system_info = f"""
üíª **TH√îNG TIN H·ªÜ TH·ªêNG**

üñ•Ô∏è **OS:** {os.name}
üêç **Python:** {sys.version}
üìÅ **Th∆∞ m·ª•c hi·ªán t·∫°i:** {os.getcwd()}
‚è∞ **Th·ªùi gian:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üìä **TR·∫†NG TH√ÅI**
ü§ñ **Admin Bot:** {bot_status}
üìÅ **Templates:** {templates_count} files
"""
            
            self.system_status_text.delete('1.0', 'end')
            self.system_status_text.insert('1.0', system_info)
            
            # System logs
            self.system_logs_text.delete('1.0', 'end')
            self.system_logs_text.insert('1.0', "üìã Log h·ªá th·ªëng s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y...")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l√†m m·ªõi tr·∫°ng th√°i: {e}")
    
    def load_config(self):
        """Load config v√†o GUI."""
        try:
            # Telegram config
            self.bot_token_entry.delete(0, 'end')
            self.bot_token_entry.insert(0, self.config['telegram']['bot_token'])
            
            self.chat_id_entry.delete(0, 'end')
            self.chat_id_entry.insert(0, self.config['telegram']['chat_id'])
            
            self.admin_ids_entry.delete(0, 'end')
            admin_ids_str = ', '.join(map(str, self.config['telegram']['admin_ids']))
            self.admin_ids_entry.insert(0, admin_ids_str)
            
            # XML config
            self.templates_folder_entry.delete(0, 'end')
            self.templates_folder_entry.insert(0, self.config['xml_templates']['input_folder'])
            
            self.exe_name_entry.delete(0, 'end')
            self.exe_name_entry.insert(0, self.config['xml_templates']['output_exe_name'])
            
            # Output path
            if hasattr(self, 'output_path_entry'):
                self.output_path_entry.delete(0, 'end')
                output_path = self.config['xml_templates'].get('output_path', os.getcwd())
                self.output_path_entry.insert(0, output_path)
            
            # Build settings
            self.auto_send_var.set(self.config['build_settings']['auto_send_telegram'])
            self.include_guardian_var.set(self.config['build_settings']['include_guardian'])
            self.include_admin_bot_var.set(self.config['build_settings']['include_admin_bot'])
            self.auto_startup_var.set(self.config['build_settings']['auto_startup'])
            
            # Refresh XML list (n·∫øu ƒë√£ ch·ªçn th∆∞ m·ª•c)
            if self.templates_folder_entry.get().strip():
                self.refresh_xml_list()
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ load config: {e}")
    
    # C√°c h√†m ph√¢n t√≠ch XML c≈© ƒë√£ ƒë∆∞·ª£c thay th·∫ø b·∫±ng quick_analyze_xml
    
    def quick_analyze_xml(self):
        """Ph√¢n t√≠ch nhanh XML trong th∆∞ m·ª•c ƒë√£ ch·ªçn."""
        folder = self.templates_folder_entry.get().strip()
        if not folder or not os.path.exists(folder):
            messagebox.showwarning("C·∫£nh b√°o", "‚ö†Ô∏è Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc tr∆∞·ªõc!")
            return
        
        try:
            xml_files = glob.glob(os.path.join(folder, "*.xml"))
            if not xml_files:
                messagebox.showinfo("Th√¥ng b√°o", "üìÇ Kh√¥ng c√≥ file XML n√†o ƒë·ªÉ ph√¢n t√≠ch!")
                return
            
            # Ph√¢n t√≠ch nhanh
            analysis_result = []
            analysis_result.append(f"üîç PH√ÇN T√çCH NHANH: {Path(folder).name}")
            analysis_result.append("=" * 50)
            analysis_result.append(f"üìÅ T·ªïng s·ªë file: {len(xml_files)}")
            
            # Th·ªëng k√™ k√≠ch th∆∞·ªõc
            total_size = sum(os.path.getsize(f) for f in xml_files)
            analysis_result.append(f"üìä T·ªïng k√≠ch th∆∞·ªõc: {total_size/1024/1024:.2f} MB")
            
            # Ph√¢n t√≠ch t·ª´ng file
            for i, xml_file in enumerate(xml_files[:5], 1):  # Ch·ªâ hi·ªÉn th·ªã 5 file ƒë·∫ßu
                filename = Path(xml_file).name
                size_kb = os.path.getsize(xml_file) / 1024
                analysis_result.append(f"\nüìÑ {i}. {filename} ({size_kb:.1f} KB)")
                
                try:
                    # Ph√¢n t√≠ch c∆° b·∫£n
                    tree = ET.parse(xml_file)
                    root = tree.getroot()
                    
                    # T√¨m c√°c tr∆∞·ªùng quan tr·ªçng - T√åM KI·∫æM TH√îNG MINH H∆†N
                    found_fields = []
                     
                    # Danh s√°ch c√°c tr∆∞·ªùng c·∫ßn t√¨m (c√≥ th·ªÉ c√≥ namespace)
                    field_patterns = [
                        # MST - M√£ s·ªë thu·∫ø
                        './/mst', './/MST', './/maSoThue', './/MaSoThue',
                        # T√™n doanh nghi·ªáp
                        './/tenNNT', './/TenNNT', './/companyName', './/CompanyName', './/tenCongTy',
                        # M√£ t·ªù khai
                        './/maTKhai', './/MaTKhai', './/maTkhai', './/MaTkhai',
                        # K·ª≥ khai
                        './/kyKKhai', './/KyKKhai', './/kyKhai', './/KyKhai',
                        # C√°c tr∆∞·ªùng kh√°c
                        './/ngayKhai', './/NgayKhai', './/thangKhai', './/ThangKhai',
                        './/namKhai', './/NamKhai', './/tongTien', './/TongTien'
                    ]
                    
                    for pattern in field_patterns:
                        try:
                            elements = root.findall(pattern)
                            if elements:
                                for elem in elements:
                                    if elem.text and elem.text.strip():
                                        field_name = pattern.split('//')[-1]  # L·∫•y t√™n tr∆∞·ªùng
                                        field_value = elem.text.strip()
                                        # Gi·ªõi h·∫°n ƒë·ªô d√†i ƒë·ªÉ d·ªÖ ƒë·ªçc
                                        if len(field_value) > 50:
                                            field_value = field_value[:50] + "..."
                                        found_fields.append(f"{field_name}: {field_value}")
                                        break  # Ch·ªâ l·∫•y tr∆∞·ªùng ƒë·∫ßu ti√™n t√¨m th·∫•y
                        except:
                            continue
                    
                    if found_fields:
                        # Hi·ªÉn th·ªã t·ªëi ƒëa 4 tr∆∞·ªùng quan tr·ªçng nh·∫•t
                        display_fields = found_fields[:4]
                        analysis_result.append(f"   ‚úÖ {', '.join(display_fields)}")
                    else:
                        # Th·ª≠ t√¨m t·∫•t c·∫£ c√°c element c√≥ text
                        all_elements = []
                        for elem in root.iter():
                            if elem.text and elem.text.strip() and len(elem.text.strip()) > 3:
                                tag_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                                all_elements.append(f"{tag_name}: {elem.text.strip()[:30]}")
                                if len(all_elements) >= 3:
                                    break
                        
                        if all_elements:
                            analysis_result.append(f"   üîç T√¨m th·∫•y: {', '.join(all_elements)}")
                        else:
                            analysis_result.append(f"   ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng c√≥ d·ªØ li·ªáu")
                        
                except Exception as e:
                    analysis_result.append(f"   ‚ùå L·ªói ph√¢n t√≠ch: {str(e)[:50]}...")
            
            if len(xml_files) > 5:
                analysis_result.append(f"\n... v√† {len(xml_files) - 5} file kh√°c")
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            result_text = '\n'.join(analysis_result)
            messagebox.showinfo("Ph√¢n T√≠ch Nhanh", result_text)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå Kh√¥ng th·ªÉ ph√¢n t√≠ch XML: {e}")
    
    def browse_output_path(self):
        """Ch·ªçn th∆∞ m·ª•c ƒë·∫ßu ra cho EXE."""
        output_path = filedialog.askdirectory(
            title="Ch·ªçn th∆∞ m·ª•c ƒë·∫ßu ra cho EXE"
        )
        if output_path:
            self.output_path_entry.delete(0, 'end')
            self.output_path_entry.insert(0, output_path)
    
    def browse_specific_exe(self):
        """Ch·ªçn file EXE c·ª• th·ªÉ."""
        exe_file = filedialog.askopenfilename(
            title="Ch·ªçn file EXE ƒë·ªÉ g·ª≠i l√™n Telegram",
            filetypes=[("EXE files", "*.exe"), ("All files", "*.*")]
        )
        if exe_file:
            self.specific_exe_entry.delete(0, 'end')
            self.specific_exe_entry.insert(0, exe_file)
            print(f"‚úÖ ƒê√£ ch·ªçn file EXE: {exe_file}")
    
    def show_available_exe_files(self):
        """Hi·ªÉn th·ªã danh s√°ch t·∫•t c·∫£ file EXE c√≥ s·∫µn."""
        try:
            exe_files = []
            
            # T√¨m trong c√°c th∆∞ m·ª•c c√≥ th·ªÉ
            search_dirs = [
                Path.cwd(),  # Th∆∞ m·ª•c hi·ªán t·∫°i
                Path(__file__).parent.parent,  # Th∆∞ m·ª•c project
            ]
            
            # Th√™m th∆∞ m·ª•c output n·∫øu c√≥
            output_path = self.output_path_entry.get().strip() if hasattr(self, 'output_path_entry') else ""
            if output_path and output_path != ".":
                search_dirs.append(Path(output_path))
            
            # T√¨m t·∫•t c·∫£ file .exe
            for base_dir in search_dirs:
                for subdir in ["", "dist", "build", "output"]:
                    search_path = base_dir / subdir
                    if search_path.exists():
                        exe_files.extend(search_path.glob("*.exe"))
            
            if not exe_files:
                messagebox.showinfo("Th√¥ng tin", "Kh√¥ng t√¨m th·∫•y file EXE n√†o!")
                return
            
            # T·∫°o danh s√°ch file v·ªõi th√¥ng tin chi ti·∫øt
            file_list = []
            for exe_file in exe_files:
                try:
                    size_mb = exe_file.stat().st_size / (1024 * 1024)
                    created_time = datetime.fromtimestamp(exe_file.stat().st_ctime)
                    file_list.append({
                        'path': str(exe_file),
                        'name': exe_file.name,
                        'size': f"{size_mb:.1f} MB",
                        'created': created_time.strftime('%Y-%m-%d %H:%M'),
                        'folder': str(exe_file.parent)
                    })
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói ƒë·ªçc file {exe_file}: {e}")
            
            # S·∫Øp x·∫øp theo th·ªùi gian t·∫°o (m·ªõi nh·∫•t tr∆∞·ªõc)
            file_list.sort(key=lambda x: x['created'], reverse=True)
            
            # T·∫°o giao di·ªán hi·ªÉn th·ªã
            self.create_exe_files_window(file_list)
            
        except Exception as e:
            print(f"‚ùå L·ªói hi·ªÉn th·ªã danh s√°ch file EXE: {e}")
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ hi·ªÉn th·ªã danh s√°ch file EXE: {e}")
    
    def create_exe_files_window(self, file_list):
        """T·∫°o c·ª≠a s·ªï hi·ªÉn th·ªã danh s√°ch file EXE."""
        # T·∫°o c·ª≠a s·ªï m·ªõi
        exe_window = tk.Toplevel(self.root)
        exe_window.title("üìã Danh s√°ch File EXE c√≥ s·∫µn")
        exe_window.geometry("800x600")
        exe_window.resizable(True, True)
        
        # Frame ch√≠nh
        main_frame = ttk.Frame(exe_window, padding=10)
        main_frame.pack(fill='both', expand=True)
        
        # Label h∆∞·ªõng d·∫´n
        ttk.Label(main_frame, text="üìã Danh s√°ch t·∫•t c·∫£ file EXE c√≥ s·∫µn:", 
                 font=('Arial', 12, 'bold')).pack(pady=(0, 10))
        
        # T·∫°o Treeview ƒë·ªÉ hi·ªÉn th·ªã danh s√°ch
        columns = ('T√™n file', 'K√≠ch th∆∞·ªõc', 'Ng√†y t·∫°o', 'Th∆∞ m·ª•c')
        tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
        
        # ƒê·ªãnh nghƒ©a c·ªôt
        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, width=150)
        
        # Th√™m d·ªØ li·ªáu
        for file_info in file_list:
            tree.insert('', 'end', values=(
                file_info['name'],
                file_info['size'],
                file_info['created'],
                file_info['folder']
            ))
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(main_frame, orient='vertical', command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        
        # Pack tree v√† scrollbar
        tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        # Frame cho c√°c n√∫t
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(10, 0))
        
        # N√∫t ch·ªçn file
        def select_file():
            selected_item = tree.selection()
            if selected_item:
                item_values = tree.item(selected_item[0])['values']
                file_name = item_values[0]
                file_folder = item_values[3]
                full_path = Path(file_folder) / file_name
                
                # C·∫≠p nh·∫≠t v√†o entry
                if hasattr(self, 'specific_exe_entry'):
                    self.specific_exe_entry.delete(0, 'end')
                    self.specific_exe_entry.insert(0, str(full_path))
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn file: {file_name}")
                exe_window.destroy()
        
        select_btn = ttk.Button(button_frame, text="‚úÖ Ch·ªçn File n√†y", command=select_file)
        select_btn.pack(side='left', padx=5)
        
        # N√∫t ƒë√≥ng
        close_btn = ttk.Button(button_frame, text="‚ùå ƒê√≥ng", command=exe_window.destroy)
        close_btn.pack(side='right', padx=5)
        
        # N√∫t l√†m m·ªõi
        refresh_btn = ttk.Button(button_frame, text="üîÑ L√†m m·ªõi", command=lambda: self.show_available_exe_files())
        refresh_btn.pack(side='left', padx=5)
    
    def save_config(self):
        """L∆∞u config t·ª´ GUI."""
        try:
            # Telegram config
            self.config['telegram']['bot_token'] = self.bot_token_entry.get().strip()
            self.config['telegram']['chat_id'] = self.chat_id_entry.get().strip()
            
            admin_ids_str = self.admin_ids_entry.get().strip()
            self.config['telegram']['admin_ids'] = [int(x.strip()) for x in admin_ids_str.split(',') if x.strip()]
            
            # XML config
            self.config['xml_templates']['input_folder'] = self.templates_folder_entry.get().strip()
            self.config['xml_templates']['output_exe_name'] = self.exe_name_entry.get().strip()
            
            # Output path
            if hasattr(self, 'output_path_entry'):
                self.config['xml_templates']['output_path'] = self.output_path_entry.get().strip()
            
            # Build settings
            self.config['build_settings']['auto_send_telegram'] = self.auto_send_var.get()
            self.config['build_settings']['include_guardian'] = self.include_guardian_var.get()
            self.config['build_settings']['include_admin_bot'] = self.include_admin_bot_var.get()
            self.config['build_settings']['auto_startup'] = self.auto_startup_var.get()
            
            # L∆∞u file
            with open('xml_protector_config.json', 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            
            messagebox.showinfo("Th√†nh c√¥ng", "Config ƒë√£ ƒë∆∞·ª£c l∆∞u!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u config: {e}")
    
    # === ENTERPRISE MANAGEMENT METHODS === #
    
    def add_company(self):
        """Th√™m doanh nghi·ªáp m·ªõi."""
        try:
            mst = self.company_mst_entry.get().strip()
            company_name = self.company_name_entry.get().strip()
            exe_name = self.company_exe_entry.get().strip()
            
            if not all([mst, company_name, exe_name]):
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!")
                return
            
            # Ki·ªÉm tra MST ƒë√£ t·ªìn t·∫°i ch∆∞a
            if mst in self.companies_data:
                messagebox.showerror("L·ªói", f"MST {mst} ƒë√£ t·ªìn t·∫°i!")
                return
            
            # T·∫°o company data
            company_data = {
                "mst": mst,
                "name": company_name,
                "exe_name": exe_name if exe_name.endswith('.exe') else exe_name + '.exe',
                "status": "Ch∆∞a deploy",
                "templates_count": 0,
                "last_deploy": "Ch∆∞a bao gi·ªù",
                "created_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "deployment_id": str(uuid.uuid4())[:8].upper(),
                "telegram_config": {
                    "bot_token": self.bot_token_entry.get().strip(),
                    "chat_id": self.chat_id_entry.get().strip(),
                    "admin_ids": self.parse_admin_ids()
                }
            }
            
            # L∆∞u v√†o companies_data
            self.companies_data[mst] = company_data
            
            # C·∫≠p nh·∫≠t config
            self.config["companies"][mst] = company_data
            
            # Refresh UI
            self.refresh_companies_list()
            
            # Clear form
            self.company_mst_entry.delete(0, 'end')
            self.company_name_entry.delete(0, 'end')
            self.company_exe_entry.delete(0, 'end')
            
            messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ th√™m doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ th√™m doanh nghi·ªáp: {e}")
    
    def refresh_companies_list(self):
        """L√†m m·ªõi danh s√°ch doanh nghi·ªáp."""
        # Clear existing items
        for item in self.companies_tree.get_children():
            self.companies_tree.delete(item)
        
        # Add companies
        for mst, company_data in self.companies_data.items():
            self.companies_tree.insert('', 'end', values=(
                company_data["mst"],
                company_data["name"],
                company_data["exe_name"],
                company_data["status"],
                company_data["templates_count"],
                company_data["last_deploy"],
                "üîß Qu·∫£n l√Ω"
            ))
    
    def select_company_for_build(self):
        """Ch·ªçn doanh nghi·ªáp ƒë·ªÉ build."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            company_name = item['values'][1]
            exe_name = item['values'][2]
            
            # Update UI v·ªõi th√¥ng tin company ƒë√£ ch·ªçn
            self.selected_company_label.configure(
                text=f"üìå ƒê√£ ch·ªçn: {company_name} ({mst})",
                foreground="green"
            )
            
            # Auto-fill exe name
            self.exe_name_entry.delete(0, 'end')
            self.exe_name_entry.insert(0, exe_name)
            
            messagebox.showinfo("ƒê√£ ch·ªçn", f"‚úÖ ƒê√£ ch·ªçn doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ch·ªçn doanh nghi·ªáp: {e}")
    
    def edit_selected_company(self):
        """S·ª≠a th√¥ng tin doanh nghi·ªáp ƒë√£ ch·ªçn."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp ƒë·ªÉ s·ª≠a!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            
            # Fill form v·ªõi th√¥ng tin hi·ªán t·∫°i
            company_data = self.companies_data.get(mst)
            if company_data:
                self.company_mst_entry.delete(0, 'end')
                self.company_mst_entry.insert(0, company_data["mst"])
                
                self.company_name_entry.delete(0, 'end')
                self.company_name_entry.insert(0, company_data["name"])
                
                self.company_exe_entry.delete(0, 'end')
                self.company_exe_entry.insert(0, company_data["exe_name"])
                
                messagebox.showinfo("Th√¥ng b√°o", f"ƒê√£ load th√¥ng tin {company_data['name']} v√†o form.\nS·ª≠a v√† nh·∫•n 'C·∫≠p Nh·∫≠t DN' ƒë·ªÉ l∆∞u.")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ s·ª≠a doanh nghi·ªáp: {e}")
    
    def delete_selected_company(self):
        """X√≥a doanh nghi·ªáp ƒë√£ ch·ªçn."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp ƒë·ªÉ x√≥a!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            company_name = item['values'][1]
            
            # X√°c nh·∫≠n x√≥a
            confirm = messagebox.askyesno(
                "X√°c nh·∫≠n x√≥a", 
                f"‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a doanh nghi·ªáp:\n\n"
                f"MST: {mst}\n"
                f"T√™n: {company_name}\n\n"
                f"H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!"
            )
            
            if confirm:
                # X√≥a kh·ªèi data
                if mst in self.companies_data:
                    del self.companies_data[mst]
                
                if mst in self.config["companies"]:
                    del self.config["companies"][mst]
                
                # Refresh UI
                self.refresh_companies_list()
                
                # Clear selection label n·∫øu company n√†y ƒëang ƒë∆∞·ª£c ch·ªçn
                if mst in self.selected_company_label.cget("text"):
                    self.selected_company_label.configure(
                        text="üìå Ch∆∞a ch·ªçn doanh nghi·ªáp n√†o",
                        foreground="blue"
                    )
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ x√≥a doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ x√≥a doanh nghi·ªáp: {e}")
    
    def export_companies_list(self):
        """Export danh s√°ch doanh nghi·ªáp ra file."""
        try:
            if not self.companies_data:
                messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë·ªÉ export!")
                return
            
            # Ch·ªçn n∆°i l∆∞u file
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                title="Export danh s√°ch doanh nghi·ªáp",
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
            )
            
            if filename:
                export_data = {
                    "exported_at": datetime.now().isoformat(),
                    "total_companies": len(self.companies_data),
                    "companies": self.companies_data
                }
                
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ export {len(self.companies_data)} doanh nghi·ªáp ra file:\n{filename}")
        
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ export: {e}")
    
    def parse_admin_ids(self):
        """Parse admin IDs t·ª´ entry."""
        try:
            admin_ids_str = self.admin_ids_entry.get().strip()
            if admin_ids_str:
                return [int(x.strip()) for x in admin_ids_str.split(',') if x.strip()]
            return []
        except:
            return []
    
    def save_secure_config(self):
        """L∆∞u config v·ªõi m√£ h√≥a."""
        try:
            # Update telegram config
            self.config["telegram"]["bot_token"] = self.bot_token_entry.get().strip()
            self.config["telegram"]["master_chat_id"] = self.chat_id_entry.get().strip()
            self.config["telegram"]["admin_ids"] = self.parse_admin_ids()
            
            # Update master admin info
            self.config["master_admin"]["created_at"] = datetime.now().isoformat()
            
            # Save v·ªõi security manager n·∫øu c√≥
            if self.security_manager and self.config_manager:
                # T·∫°o master config file
                master_config_file = Path("master_config.enc")
                with open(master_config_file, 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", "‚úÖ Config ƒë√£ ƒë∆∞·ª£c l∆∞u v·ªõi m√£ h√≥a!")
            else:
                # Fallback - save normal file
                with open('xml_protector_config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", "‚úÖ Config ƒë√£ ƒë∆∞·ª£c l∆∞u!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u config: {e}")
    
    def load_secure_config(self):
        """Load config an to√†n."""
        try:
            # Th·ª≠ load t·ª´ master config tr∆∞·ªõc
            master_config_file = Path("master_config.enc")
            if master_config_file.exists():
                with open(master_config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
                    self.companies_data = self.config.get("companies", {})
            else:
                # Fallback - load t·ª´ file c≈©
                old_config_file = Path('xml_protector_config.json')
                if old_config_file.exists():
                    with open(old_config_file, 'r', encoding='utf-8') as f:
                        old_config = json.load(f)
                        # Migrate old config
                        self.migrate_old_config(old_config)
            
            # Load v√†o GUI
            self.load_config_to_gui()
            
        except Exception as e:
            print(f"‚ö†Ô∏è Load config warning: {e}")
            # S·ª≠ d·ª•ng template m·∫∑c ƒë·ªãnh
            pass
    
    def migrate_old_config(self, old_config):
        """Migration t·ª´ config c≈© sang format m·ªõi."""
        try:
            # Migrate telegram settings
            if "telegram" in old_config:
                self.config["telegram"]["bot_token"] = old_config["telegram"].get("bot_token", "")
                self.config["telegram"]["master_chat_id"] = old_config["telegram"].get("chat_id", "")
                self.config["telegram"]["admin_ids"] = old_config["telegram"].get("admin_ids", [])
            
            # Migrate build settings
            if "build_settings" in old_config:
                self.config["build_settings"].update(old_config["build_settings"])
            
            print("‚úÖ ƒê√£ migration config c≈© th√†nh c√¥ng")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Migration warning: {e}")
    
    def load_config_to_gui(self):
        """Load config v√†o GUI elements."""
        try:
            # Load telegram config
            telegram_config = self.config.get("telegram", {})
            
            self.bot_token_entry.delete(0, 'end')
            self.bot_token_entry.insert(0, telegram_config.get("bot_token", ""))
            
            self.chat_id_entry.delete(0, 'end')
            self.chat_id_entry.insert(0, telegram_config.get("master_chat_id", ""))
            
            self.admin_ids_entry.delete(0, 'end')
            admin_ids_str = ', '.join(map(str, telegram_config.get("admin_ids", [])))
            self.admin_ids_entry.insert(0, admin_ids_str)
            
            # Load companies
            self.refresh_companies_list()
            
            # Load enterprises
            self.refresh_enterprises_list()
            
        except Exception as e:
            print(f"‚ö†Ô∏è Load to GUI warning: {e}")
    
    def load_enterprises(self):
        """Load danh s√°ch doanh nghi·ªáp t·ª´ file."""
        try:
            if os.path.exists("enterprises.json"):
                with open("enterprises.json", "r", encoding="utf-8") as f:
                    self.enterprises = json.load(f)
                print(f"‚úÖ ƒê√£ load {len(self.enterprises)} doanh nghi·ªáp")
            else:
                # T·∫°o danh s√°ch m·∫´u
                self.enterprises = {
                    "DN001": {
                        "name": "C√¥ng ty ABC",
                        "bot_token": "8401477107:AAFZGt57qmTDcxKpgt4QMfPBK7cslUZo4wU",
                        "chat_id": "-1002147483647",
                        "admin_id": 5343328909,
                        "status": "active",
                        "last_build": None,
                        "last_deploy": None
                    }
                }
                self.save_enterprises()
        except Exception as e:
            print(f"‚ùå L·ªói load enterprises: {e}")
            self.enterprises = {}
    
    def save_enterprises(self):
        """L∆∞u danh s√°ch doanh nghi·ªáp."""
        try:
            with open("enterprises.json", "w", encoding="utf-8") as f:
                json.dump(self.enterprises, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ùå L·ªói save enterprises: {e}")
    
    def init_enterprise_manager(self):
        """Kh·ªüi t·∫°o Enterprise Manager."""
        try:
            # T·∫°o th∆∞ m·ª•c configs n·∫øu ch∆∞a c√≥
            os.makedirs("configs", exist_ok=True)
            print("‚úÖ Enterprise Manager ƒë√£ s·∫µn s√†ng")
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi t·∫°o Enterprise Manager: {e}")
    
    def auto_detect_enterprises_from_xml(self):
        """T·ª± ƒë·ªông ph√°t hi·ªán v√† ph√¢n lo·∫°i doanh nghi·ªáp t·ª´ XML templates m·ªôt c√°ch th√¥ng minh."""
        try:
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i
            self.smart_status_label.config(text="üîç ƒêang ph√¢n t√≠ch XML ƒë·ªÉ ph√°t hi·ªán doanh nghi·ªáp...", foreground="blue")
            
            templates_folder = self.templates_folder_entry.get().strip()
            if not templates_folder or not os.path.exists(templates_folder):
                messagebox.showerror("L·ªói", "‚ùå Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc tr∆∞·ªõc!")
                self.smart_status_label.config(text="‚ùå Ch∆∞a ch·ªçn th∆∞ m·ª•c XML g·ªëc", foreground="red")
                return
            
            # T√¨m t·∫•t c·∫£ file XML
            xml_files = []
            for file in os.listdir(templates_folder):
                if file.lower().endswith('.xml'):
                    xml_files.append(os.path.join(templates_folder, file))
            
            if not xml_files:
                messagebox.showinfo("Th√¥ng b√°o", "üí° Kh√¥ng t√¨m th·∫•y file XML n√†o trong th∆∞ m·ª•c ƒë√£ ch·ªçn!")
                self.smart_status_label.config(text="‚ùå Kh√¥ng t√¨m th·∫•y file XML", foreground="orange")
                return
            
            # Ph√¢n t√≠ch t·ª´ng file XML
            detected_enterprises = []
            for xml_file in xml_files:
                try:
                    # Parse XML ƒë·ªÉ l·∫•y th√¥ng tin
                    tree = ET.parse(xml_file)
                    root = tree.getroot()
                    
                    # T√¨m MST v√† t√™n doanh nghi·ªáp
                    mst = None
                    company_name = None
                    
                    # T√¨m MST trong c√°c th·∫ª c√≥ th·ªÉ ch·ª©a MST
                    mst_candidates = [
                        './/mst', './/MST', './/ma_so_thue', './/MaSoThue',
                        './/tax_code', './/TaxCode', './/tax_number', './/TaxNumber'
                    ]
                    
                    for mst_path in mst_candidates:
                        mst_elem = root.find(mst_path)
                        if mst_elem is not None and mst_elem.text:
                            mst = mst_elem.text.strip()
                            break
                    
                    # T√¨m t√™n doanh nghi·ªáp
                    name_candidates = [
                        './/ten_doanh_nghiep', './/TenDoanhNghiep',
                        './/company_name', './/CompanyName', './/ten_cong_ty',
                        './/TenCongTy', './/ten_dn', './/TenDN'
                    ]
                    
                    for name_path in name_candidates:
                        name_elem = root.find(name_path)
                        if name_elem is not None and name_elem.text:
                            company_name = name_elem.text.strip()
                            break
                    
                    # N·∫øu kh√¥ng t√¨m th·∫•y, s·ª≠ d·ª•ng t√™n file
                    if not company_name:
                        company_name = os.path.splitext(os.path.basename(xml_file))[0]
                    
                    # T·∫°o m√£ doanh nghi·ªáp t·ª´ MST ho·∫∑c t√™n
                    if mst:
                        enterprise_code = f"DN{mst[-4:]}" if len(mst) >= 4 else f"DN{mst}"
                    else:
                        # T·∫°o m√£ t·ª´ t√™n doanh nghi·ªáp
                        enterprise_code = f"DN{len(detected_enterprises) + 1:03d}"
                    
                    # Ki·ªÉm tra xem doanh nghi·ªáp ƒë√£ t·ªìn t·∫°i ch∆∞a
                    existing_enterprise = None
                    for code, ent in self.enterprises.items():
                        if (ent.get('mst') == mst and mst) or (ent.get('xml_template') == xml_file):
                            existing_enterprise = code
                            break
                    
                    if existing_enterprise:
                        # C·∫≠p nh·∫≠t doanh nghi·ªáp hi·ªán c√≥
                        self.enterprises[existing_enterprise].update({
                            'name': company_name,
                            'mst': mst,
                            'xml_template': xml_file,
                            'last_update': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        })
                        detected_enterprises.append(existing_enterprise)
                    else:
                        # T·∫°o doanh nghi·ªáp m·ªõi
                        enterprise_data = {
                            'name': company_name,
                            'mst': mst,
                            'xml_template': xml_file,
                            'status': 'pending',
                            'created': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            'last_update': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            'bot_token': '',
                            'chat_id': '',
                            'admin_id': ''
                        }
                        
                        self.enterprises[enterprise_code] = enterprise_data
                        detected_enterprises.append(enterprise_code)
                        
                except Exception as e:
                    print(f"‚ùå L·ªói ph√¢n t√≠ch XML {xml_file}: {e}")
                    continue
            
            if detected_enterprises:
                # L∆∞u thay ƒë·ªïi
                self.save_enterprises()
                
                # L√†m m·ªõi GUI
                self.refresh_enterprises_list()
                
                # C·∫≠p nh·∫≠t tr·∫°ng th√°i
                self.smart_status_label.config(text=f"‚úÖ ƒê√£ ph√°t hi·ªán {len(detected_enterprises)} doanh nghi·ªáp t·ª´ {len(xml_files)} file XML", foreground="green")
                self.xml_detection_label.config(text=f" | üìÑ XML: {len(xml_files)} files")
                
                # Hi·ªÉn th·ªã k·∫øt qu·∫£
                result_text = f"""üîç PH√ÅT HI·ªÜN DOANH NGHI·ªÜP TH√ÄNH C√îNG!

üìä K·∫øt qu·∫£:
‚Ä¢ T·ªïng file XML: {len(xml_files)}
‚Ä¢ Doanh nghi·ªáp ph√°t hi·ªán: {len(detected_enterprises)}
‚Ä¢ Doanh nghi·ªáp m·ªõi: {len([e for e in detected_enterprises if self.enterprises[e]['status'] == 'pending'])}
‚Ä¢ Doanh nghi·ªáp c·∫≠p nh·∫≠t: {len([e for e in detected_enterprises if self.enterprises[e]['status'] != 'pending'])}

üí° Ti·∫øp theo: Nh·∫•n 'Build T·∫•t C·∫£ DN Pending' ƒë·ªÉ t·∫°o EXE!"""
                
                messagebox.showinfo("Ph√°t Hi·ªán Th√†nh C√¥ng", result_text)
                
            else:
                self.smart_status_label.config(text="‚ùå Kh√¥ng th·ªÉ ph√°t hi·ªán doanh nghi·ªáp t·ª´ XML", foreground="red")
                messagebox.showwarning("C·∫£nh b√°o", "‚ö†Ô∏è Kh√¥ng th·ªÉ ph√°t hi·ªán doanh nghi·ªáp n√†o t·ª´ c√°c file XML!")
                
        except Exception as e:
            error_msg = f"‚ùå L·ªói khi ph√°t hi·ªán doanh nghi·ªáp: {e}"
            print(error_msg)
            messagebox.showerror("L·ªói", error_msg)
            self.smart_status_label.config(text="‚ùå L·ªói ph√°t hi·ªán doanh nghi·ªáp", foreground="red")
    
    def build_enterprise_exe(self, enterprise_code):
        """Build EXE cho doanh nghi·ªáp c·ª• th·ªÉ."""
        if enterprise_code not in self.enterprises:
            return False, "Kh√¥ng t√¨m th·∫•y doanh nghi·ªáp"
        
        enterprise = self.enterprises[enterprise_code]
        
        try:
            # T·∫°o config ri√™ng cho doanh nghi·ªáp
            config = {
                "telegram": {
                    "bot_token": enterprise["bot_token"],
                    "chat_id": enterprise["chat_id"],
                    "admin_ids": [enterprise["admin_id"]]
                },
                "xml_templates": {
                    "input_folder": "templates",
                    "monitor_drives": ["C:\\", "D:\\", "E:\\", "F:\\", "G:\\", "H:\\"]
                },
                "security": {
                    "backup_enabled": True,
                    "log_level": "INFO",
                    "auto_restart": True
                }
            }
            
            # L∆∞u config ri√™ng
            config_file = f"configs/{enterprise_code}_config.json"
            os.makedirs("configs", exist_ok=True)
            
            with open(config_file, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            
            # Build EXE v·ªõi PyInstaller
            exe_name = f"{enterprise_code}_Protector"
            build_cmd = f'pyinstaller --onefile --windowed --name="{exe_name}" --add-data="templates;templates" --add-data="{config_file};config" --add-data="logs;logs" src/xml_protector_runtime.py'
            
            # Ch·∫°y build command
            result = os.system(build_cmd)
            
            if result == 0:
                # C·∫≠p nh·∫≠t tr·∫°ng th√°i
                enterprise["last_build"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                enterprise["status"] = "built"
                self.save_enterprises()
                self.refresh_enterprises_list()
                
                return True, f"‚úÖ Build EXE th√†nh c√¥ng: {exe_name}.exe"
            else:
                return False, f"‚ùå L·ªói build EXE (exit code: {result})"
                
        except Exception as e:
            return False, f"‚ùå L·ªói build EXE: {str(e)}"
    
    def deploy_to_enterprise(self, enterprise_code):
        """Deploy EXE l√™n Telegram cho doanh nghi·ªáp."""
        if enterprise_code not in self.enterprises:
            return False, "Kh√¥ng t√¨m th·∫•y doanh nghi·ªáp"
        
        enterprise = self.enterprises[enterprise_code]
        exe_name = f"{enterprise_code}_Protector.exe"
        exe_path = f"dist/{exe_name}"
        
        if not os.path.exists(exe_path):
            return False, f"Kh√¥ng t√¨m th·∫•y file EXE: {exe_path}"
        
        try:
            # G·ª≠i EXE l√™n Telegram
            bot_token = self.config.get("telegram", {}).get("bot_token", "")
            chat_id = self.config.get("telegram", {}).get("master_chat_id", "")
            
            if not bot_token or not chat_id:
                return False, "Ch∆∞a c·∫•u h√¨nh Telegram Bot"
            
            session = requests.Session()
            session.verify = False
            session.trust_env = False
            
            url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
            
            with open(exe_path, "rb") as f:
                files = {"document": f}
                data = {
                    "chat_id": chat_id,
                    "caption": f"""üöÄ **XML PROTECTOR EXE CHO {enterprise['name']}**

üìÑ **File:** `{exe_name}`
üè¢ **Doanh nghi·ªáp:** {enterprise['name']} ({enterprise_code})
üì¶ **K√≠ch th∆∞·ªõc:** {os.path.getsize(exe_path) / (1024*1024):.1f} MB
üïê **Build time:** {enterprise['last_build']}

‚úÖ **T√≠nh nƒÉng:**
‚Ä¢ XML Protection
‚Ä¢ Template Matching  
‚Ä¢ Auto-restart
‚Ä¢ Telegram Alerts

üîê **B·∫£o m·∫≠t:** Enterprise Grade
üì± **S·∫µn s√†ng tri·ªÉn khai!**""",
                    "parse_mode": "Markdown"
                }
                
                response = session.post(url, files=files, data=data, timeout=300)
                
                if response.status_code == 200:
                    # C·∫≠p nh·∫≠t tr·∫°ng th√°i
                    enterprise["last_deploy"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    enterprise["status"] = "deployed"
                    self.save_enterprises()
                    self.refresh_enterprises_list()
                    
                    return True, f"‚úÖ Deploy th√†nh c√¥ng EXE cho {enterprise['name']}"
                else:
                    return False, f"‚ùå L·ªói deploy: {response.status_code}"
                    
        except Exception as e:
            return False, f"‚ùå L·ªói deploy: {str(e)}"
    
    def refresh_enterprises_list(self):
        """Refresh danh s√°ch doanh nghi·ªáp trong GUI m·ªôt c√°ch th√¥ng minh."""
        try:
            # X√≥a danh s√°ch c≈©
            for widget in self.enterprises_list_frame.winfo_children():
                widget.destroy()
            
            # Ki·ªÉm tra xem c√≥ doanh nghi·ªáp n√†o kh√¥ng
            if not self.enterprises:
                # Hi·ªÉn th·ªã th√¥ng b√°o "kh√¥ng c√≥ doanh nghi·ªáp"
                self.no_enterprises_label = ttk.Label(self.enterprises_list_frame, 
                                                     text="üí° Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë∆∞·ª£c ph√°t hi·ªán.\nNh·∫•n 'T·ª± ƒê·ªông Ph√°t Hi·ªán & Ph√¢n Lo·∫°i DN' ƒë·ªÉ b·∫Øt ƒë·∫ßu!", 
                                                     font=('Arial', 10), foreground="gray", justify='center')
                self.no_enterprises_label.pack(pady=20)
                
                # C·∫≠p nh·∫≠t tr·∫°ng th√°i
                self.smart_status_label.config(text="üîç Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë∆∞·ª£c ph√°t hi·ªán", foreground="orange")
                self.xml_detection_label.config(text=" | üìÑ XML: 0 files")
            else:
                # T·∫°o danh s√°ch m·ªõi
                for code, enterprise in self.enterprises.items():
                    self.create_enterprise_item(code, enterprise)
                
                # C·∫≠p nh·∫≠t tr·∫°ng th√°i
                xml_count = len([e for e in self.enterprises.values() if 'xml_template' in e])
                self.smart_status_label.config(text=f"‚úÖ ƒê√£ ph√°t hi·ªán {len(self.enterprises)} doanh nghi·ªáp t·ª´ XML", foreground="green")
                self.xml_detection_label.config(text=f" | üìÑ XML: {xml_count} files")
            
            # C·∫≠p nh·∫≠t th·ªëng k√™
            self.update_enterprises_stats()
                
        except Exception as e:
            print(f"‚ùå L·ªói refresh enterprises list: {e}")
            self.smart_status_label.config(text="‚ùå L·ªói khi l√†m m·ªõi danh s√°ch", foreground="red")
    
    def create_enterprise_item(self, code, enterprise):
        """T·∫°o item doanh nghi·ªáp th√¥ng minh trong GUI."""
        try:
            # ·∫®n th√¥ng b√°o "kh√¥ng c√≥ doanh nghi·ªáp"
            if hasattr(self, 'no_enterprises_label'):
                self.no_enterprises_label.pack_forget()
            
            item_frame = ttk.LabelFrame(self.enterprises_list_frame, text=f"üè¢ {enterprise['name']} ({code})", padding=8)
            item_frame.pack(fill='x', padx=5, pady=3)
            
            # Th√¥ng tin ch√≠nh c·ªßa doanh nghi·ªáp
            main_info_frame = ttk.Frame(item_frame)
            main_info_frame.pack(fill='x', pady=2)
            
            # C·ªôt th√¥ng tin b√™n tr√°i
            left_info = ttk.Frame(main_info_frame)
            left_info.pack(side='left', fill='x', expand=True)
            
            # MST v√† th√¥ng tin c∆° b·∫£n
            if 'mst' in enterprise and enterprise['mst']:
                mst_label = ttk.Label(left_info, text=f"üî¢ MST: {enterprise['mst']}", 
                                     font=('Arial', 9, 'bold'), foreground="darkblue")
                mst_label.pack(anchor='w')
            
            # Tr·∫°ng th√°i v·ªõi m√†u s·∫Øc v√† emoji
            status_emoji = {
                "pending": "‚è≥",
                "built": "üî®", 
                "deployed": "‚úÖ",
                "active": "üü¢"
            }.get(enterprise["status"], "‚ùì")
            
            status_colors = {
                "pending": "orange",
                "built": "blue", 
                "deployed": "green",
                "active": "darkgreen"
            }.get(enterprise["status"], "gray")
            
            status_label = ttk.Label(left_info, text=f"üìä Tr·∫°ng th√°i: {status_emoji} {enterprise['status'].upper()}", 
                                   font=('Arial', 9, 'bold'), foreground=status_colors)
            status_label.pack(anchor='w')
            
            # Th√¥ng tin XML template
            if 'xml_template' in enterprise:
                xml_label = ttk.Label(left_info, text=f"üìÑ Template: {os.path.basename(enterprise['xml_template'])}", 
                                     font=('Arial', 8), foreground="purple")
                xml_label.pack(anchor='w')
            
            # C·ªôt th√¥ng tin b√™n ph·∫£i
            right_info = ttk.Frame(main_info_frame)
            right_info.pack(side='right', fill='y')
            
            # Th·ªùi gian c·∫≠p nh·∫≠t cu·ªëi
            if 'last_update' in enterprise:
                time_label = ttk.Label(right_info, text=f"üïê {enterprise['last_update']}", 
                                     font=('Arial', 8), foreground="gray")
                time_label.pack(anchor='e')
            
            # N√∫t ƒëi·ªÅu khi·ªÉn th√¥ng minh
            controls_frame = ttk.Frame(item_frame)
            controls_frame.pack(fill='x', pady=5)
            
            # N√∫t theo tr·∫°ng th√°i
            if enterprise["status"] == "pending":
                ttk.Button(controls_frame, text="üî® Build EXE", 
                          command=lambda: self.build_enterprise_exe_ui(code)).pack(side='left', padx=2)
                ttk.Button(controls_frame, text="üìÑ Xem XML", 
                          command=lambda: self.view_enterprise_xml(code)).pack(side='left', padx=2)
            elif enterprise["status"] == "built":
                ttk.Button(controls_frame, text="üöÄ Deploy", 
                          command=lambda: self.deploy_enterprise_ui(code)).pack(side='left', padx=2)
                ttk.Button(controls_frame, text="üîÑ Build l·∫°i", 
                          command=lambda: self.build_enterprise_exe_ui(code)).pack(side='left', padx=2)
                ttk.Button(controls_frame, text="üìÑ Xem XML", 
                          command=lambda: self.view_enterprise_xml(code)).pack(side='left', padx=2)
            elif enterprise["status"] == "deployed":
                ttk.Button(controls_frame, text="üìä Xem Log", 
                          command=lambda: self.view_enterprise_logs(code)).pack(side='left', padx=2)
                ttk.Button(controls_frame, text="üîÑ Build l·∫°i", 
                          command=lambda: self.build_enterprise_exe_ui(code)).pack(side='left', padx=2)
                ttk.Button(controls_frame, text="üìÑ Xem XML", 
                          command=lambda: self.view_enterprise_xml(code)).pack(side='left', padx=2)
            
            # N√∫t x√≥a doanh nghi·ªáp
            ttk.Button(controls_frame, text="üóëÔ∏è X√≥a", 
                      command=lambda: self.delete_enterprise(code)).pack(side='right', padx=2)
            
            # Separator
            ttk.Separator(item_frame, orient='horizontal').pack(fill='x', pady=3)
            
        except Exception as e:
            print(f"‚ùå L·ªói t·∫°o enterprise item: {e}")
    
    def build_enterprise_exe_ui(self, enterprise_code):
        """Build EXE cho doanh nghi·ªáp t·ª´ GUI."""
        try:
            success, message = self.build_enterprise_exe(enterprise_code)
            messagebox.showinfo("K·∫øt qu·∫£ Build", message)
            
            if success:
                self.refresh_enterprises_list()
                
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói build EXE: {e}")
    
    def deploy_enterprise_ui(self, enterprise_code):
        """Deploy EXE cho doanh nghi·ªáp t·ª´ GUI."""
        try:
            success, message = self.deploy_to_enterprise(enterprise_code)
            messagebox.showinfo("K·∫øt qu·∫£ Deploy", message)
            
            if success:
                self.refresh_enterprises_list()
                
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói deploy: {e}")
    
    def view_enterprise_logs(self, enterprise_code):
        """Xem log c·ªßa doanh nghi·ªáp."""
        try:
            enterprise = self.enterprises.get(enterprise_code, {})
            log_text = f"""üìä **LOG C·ª¶A {enterprise.get('name', 'Unknown')}**

üè¢ **M√£ DN:** {enterprise_code}
üìÖ **Tr·∫°ng th√°i:** {enterprise.get('status', 'Unknown')}
üî® **Build cu·ªëi:** {enterprise.get('last_build', 'Ch∆∞a c√≥')}
üöÄ **Deploy cu·ªëi:** {enterprise.get('last_deploy', 'Ch∆∞a c√≥')}

üì± **Th√¥ng tin li√™n l·∫°c:**
‚Ä¢ Bot Token: {enterprise.get('bot_token', 'Ch∆∞a c·∫•u h√¨nh')}
‚Ä¢ Chat ID: {enterprise.get('chat_id', 'Ch∆∞a c·∫•u h√¨nh')}
‚Ä¢ Admin ID: {enterprise.get('admin_id', 'Ch∆∞a c·∫•u h√¨nh')}"""
            
            messagebox.showinfo(f"Log {enterprise_code}", log_text)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói xem log: {e}")
    
    def build_all_pending_enterprises(self):
        """Build t·∫•t c·∫£ doanh nghi·ªáp ƒëang pending."""
        try:
            pending = [code for code, ent in self.enterprises.items() if ent["status"] == "pending"]
            
            if not pending:
                messagebox.showinfo("Th√¥ng b√°o", "‚úÖ Kh√¥ng c√≥ doanh nghi·ªáp n√†o c·∫ßn build")
                return
            
            # H·ªèi x√°c nh·∫≠n
            confirm = messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ mu·ªën build t·∫•t c·∫£ {len(pending)} doanh nghi·ªáp pending kh√¥ng?")
            if not confirm:
                return
            
            results = []
            for code in pending:
                success, message = self.build_enterprise_exe(code)
                results.append(f"{code}: {message}")
                
                # C·∫≠p nh·∫≠t GUI
                self.refresh_enterprises_list()
                self.update_enterprises_stats()
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            result_text = "\n".join(results)
            messagebox.showinfo("K·∫øt qu·∫£ Build", result_text)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói build t·∫•t c·∫£: {e}")
    
    def deploy_all_built_enterprises(self):
        """Deploy t·∫•t c·∫£ doanh nghi·ªáp ƒë√£ built."""
        try:
            built = [code for code, ent in self.enterprises.items() if ent["status"] == "built"]
            
            if not built:
                messagebox.showinfo("Th√¥ng b√°o", "‚úÖ Kh√¥ng c√≥ doanh nghi·ªáp n√†o c·∫ßn deploy")
                return
            
            # H·ªèi x√°c nh·∫≠n
            confirm = messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ mu·ªën deploy t·∫•t c·∫£ {len(built)} doanh nghi·ªáp ƒë√£ built kh√¥ng?")
            if not confirm:
                return
            
            results = []
            for code in built:
                success, message = self.deploy_to_enterprise(code)
                results.append(f"{code}: {message}")
                
                # C·∫≠p nh·∫≠t GUI
                self.refresh_enterprises_list()
                self.update_enterprises_stats()
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            result_text = "\n".join(results)
            messagebox.showinfo("K·∫øt qu·∫£ Deploy", result_text)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói deploy t·∫•t c·∫£: {e}")
    
    def update_enterprises_stats(self):
        """C·∫≠p nh·∫≠t th·ªëng k√™ doanh nghi·ªáp m·ªôt c√°ch th√¥ng minh."""
        try:
            total = len(self.enterprises)
            
            if total == 0:
                stats_text = "üìä Th·ªëng k√™: Ch∆∞a c√≥ doanh nghi·ªáp n√†o"
                self.enterprises_stats_label.config(text=stats_text)
                return
            
            # Ph√¢n lo·∫°i theo tr·∫°ng th√°i
            pending = len([e for e in self.enterprises.values() if e["status"] == "pending"])
            built = len([e for e in self.enterprises.values() if e["status"] == "built"])
            deployed = len([e for e in self.enterprises.values() if e["status"] == "deployed"])
            active = len([e for e in self.enterprises.values() if e["status"] == "active"])
            
            # Th·ªëng k√™ XML templates
            xml_templates = len([e for e in self.enterprises.values() if 'xml_template' in e])
            mst_count = len([e for e in self.enterprises.values() if e.get('mst')])
            
            # T·∫°o th·ªëng k√™ th√¥ng minh
            if total == 1:
                enterprise = list(self.enterprises.values())[0]
                stats_text = f"üìä 1 doanh nghi·ªáp: {enterprise['name']} ({enterprise['status']})"
            else:
                # Th·ªëng k√™ t·ªïng quan
                stats_parts = [f"üìä {total} DN"]
                
                if pending > 0:
                    stats_parts.append(f"‚è≥ {pending}")
                if built > 0:
                    stats_parts.append(f"üî® {built}")
                if deployed > 0:
                    stats_parts.append(f"‚úÖ {deployed}")
                if active > 0:
                    stats_parts.append(f"üü¢ {active}")
                
                stats_text = " | ".join(stats_parts)
                
                # Th√™m th√¥ng tin chi ti·∫øt n·∫øu c√≥
                if xml_templates > 0:
                    stats_text += f" | üìÑ {xml_templates} XML"
                if mst_count > 0:
                    stats_text += f" | üî¢ {mst_count} MST"
            
            self.enterprises_stats_label.config(text=stats_text)
            
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i th√¥ng minh
            if hasattr(self, 'smart_status_label'):
                if total == 0:
                    self.smart_status_label.config(text="üîç Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë∆∞·ª£c ph√°t hi·ªán", foreground="orange")
                elif pending > 0:
                    self.smart_status_label.config(text=f"‚è≥ C√≥ {pending} doanh nghi·ªáp ƒëang ch·ªù build", foreground="orange")
                elif built > 0:
                    self.smart_status_label.config(text=f"üî® C√≥ {built} doanh nghi·ªáp ƒë√£ build, s·∫µn s√†ng deploy", foreground="blue")
                elif deployed > 0:
                    self.smart_status_label.config(text=f"‚úÖ C√≥ {deployed} doanh nghi·ªáp ƒë√£ deploy", foreground="green")
                else:
                    self.smart_status_label.config(text=f"‚úÖ Qu·∫£n l√Ω {total} doanh nghi·ªáp th√†nh c√¥ng", foreground="green")
            
        except Exception as e:
            print(f"‚ùå L·ªói c·∫≠p nh·∫≠t stats: {e}")
            self.enterprises_stats_label.config(text="üìä L·ªói c·∫≠p nh·∫≠t th·ªëng k√™")
    
    def run(self):
        """Ch·∫°y GUI."""
        self.root.mainloop()
    
    def smart_refresh_enterprises(self):
        """L√†m m·ªõi th√¥ng minh danh s√°ch doanh nghi·ªáp."""
        try:
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i
            self.smart_status_label.config(text="üîÑ ƒêang l√†m m·ªõi danh s√°ch...", foreground="blue")
            
            # T·ª± ƒë·ªông ph√°t hi·ªán l·∫°i t·ª´ XML
            self.auto_detect_enterprises_from_xml()
            
            # L√†m m·ªõi GUI
            self.refresh_enterprises_list()
            
            messagebox.showinfo("Th√¥ng b√°o", "‚úÖ ƒê√£ l√†m m·ªõi danh s√°ch doanh nghi·ªáp th√†nh c√¥ng!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå L·ªói khi l√†m m·ªõi: {e}")
            self.smart_status_label.config(text="‚ùå L·ªói khi l√†m m·ªõi", foreground="red")
    
    def show_xml_enterprise_details(self):
        """Hi·ªÉn th·ªã chi ti·∫øt XML v√† doanh nghi·ªáp ƒë∆∞·ª£c ph√°t hi·ªán."""
        try:
            if not self.enterprises:
                messagebox.showinfo("Th√¥ng b√°o", "üí° Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë∆∞·ª£c ph√°t hi·ªán!")
                return
            
            # T·∫°o c·ª≠a s·ªï chi ti·∫øt
            details_window = tk.Toplevel(self.root)
            details_window.title("üìÑ Chi Ti·∫øt XML & Doanh Nghi·ªáp")
            details_window.geometry("800x600")
            
            # Notebook ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin
            notebook = ttk.Notebook(details_window)
            notebook.pack(fill='both', expand=True, padx=10, pady=10)
            
            # Tab 1: T·ªïng quan doanh nghi·ªáp
            overview_frame = ttk.Frame(notebook)
            notebook.add(overview_frame, text="üè¢ T·ªïng Quan DN")
            
            # Treeview cho doanh nghi·ªáp
            columns = ('M√£ DN', 'T√™n DN', 'MST', 'Tr·∫°ng th√°i', 'Template XML', 'C·∫≠p nh·∫≠t cu·ªëi')
            overview_tree = ttk.Treeview(overview_frame, columns=columns, show='headings', height=15)
            
            for col in columns:
                overview_tree.heading(col, text=col)
                if col in ['M√£ DN', 'MST']:
                    overview_tree.column(col, width=100)
                elif col == 'T√™n DN':
                    overview_tree.column(col, width=200)
                elif col == 'Template XML':
                    overview_tree.column(col, width=150)
                else:
                    overview_tree.column(col, width=120)
            
            overview_tree.pack(fill='both', expand=True, padx=5, pady=5)
            
            # Th√™m d·ªØ li·ªáu
            for code, enterprise in self.enterprises.items():
                overview_tree.insert('', 'end', values=(
                    code,
                    enterprise.get('name', ''),
                    enterprise.get('mst', ''),
                    enterprise.get('status', ''),
                    os.path.basename(enterprise.get('xml_template', '')) if 'xml_template' in enterprise else '',
                    enterprise.get('last_update', '')
                ))
            
            # Tab 2: Chi ti·∫øt XML templates
            xml_frame = ttk.Frame(notebook)
            notebook.add(xml_frame, text="üìÑ Chi Ti·∫øt XML")
            
            xml_text = tk.Text(xml_frame, wrap='word', font=('Consolas', 9))
            xml_text.pack(fill='both', expand=True, padx=5, pady=5)
            
            xml_content = "üìÑ CHI TI·∫æT XML TEMPLATES:\n\n"
            for code, enterprise in self.enterprises.items():
                if 'xml_template' in enterprise:
                    xml_content += f"üè¢ {enterprise['name']} ({code}):\n"
                    xml_content += f"   üìÅ File: {enterprise['xml_template']}\n"
                    xml_content += f"   üî¢ MST: {enterprise.get('mst', 'N/A')}\n"
                    xml_content += f"   üìä Tr·∫°ng th√°i: {enterprise.get('status', 'N/A')}\n\n"
            
            xml_text.insert('1.0', xml_content)
            xml_text.config(state='disabled')
            
            # Tab 3: Th·ªëng k√™
            stats_frame = ttk.Frame(notebook)
            notebook.add(stats_frame, text="üìä Th·ªëng K√™")
            
            stats_text = tk.Text(stats_frame, wrap='word', font=('Arial', 10))
            stats_text.pack(fill='both', expand=True, padx=5, pady=5)
            
            total = len(self.enterprises)
            pending = len([e for e in self.enterprises.values() if e["status"] == "pending"])
            built = len([e for e in self.enterprises.values() if e["status"] == "built"])
            deployed = len([e for e in self.enterprises.values() if e["status"] == "deployed"])
            active = len([e for e in self.enterprises.values() if e["status"] == "active"])
            
            stats_content = f"""üìä TH·ªêNG K√ä CHI TI·∫æT:

üè¢ T·ªïng s·ªë doanh nghi·ªáp: {total}
‚è≥ ƒêang ch·ªù build: {pending}
üî® ƒê√£ build: {built}
‚úÖ ƒê√£ deploy: {deployed}
üü¢ ƒêang ho·∫°t ƒë·ªông: {active}

üìÑ XML Templates ƒë∆∞·ª£c s·ª≠ d·ª•ng: {len([e for e in self.enterprises.values() if 'xml_template' in e])}

üîç PH√ÇN T√çCH THEO TR·∫†NG TH√ÅI:
"""
            
            for status in ["pending", "built", "deployed", "active"]:
                count = len([e for e in self.enterprises.values() if e["status"] == status])
                if count > 0:
                    status_names = {"pending": "Ch·ªù build", "built": "ƒê√£ build", "deployed": "ƒê√£ deploy", "active": "Ho·∫°t ƒë·ªông"}
                    stats_content += f"‚Ä¢ {status_names.get(status, status)}: {count} DN\n"
            
            stats_text.insert('1.0', stats_content)
            stats_text.config(state='disabled')
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå L·ªói khi hi·ªÉn th·ªã chi ti·∫øt: {e}")
    
    def view_enterprise_xml(self, enterprise_code):
        """Xem XML template c·ªßa doanh nghi·ªáp."""
        try:
            enterprise = self.enterprises.get(enterprise_code, {})
            
            if 'xml_template' not in enterprise or not os.path.exists(enterprise['xml_template']):
                messagebox.showwarning("C·∫£nh b√°o", f"‚ùå Kh√¥ng t√¨m th·∫•y XML template cho {enterprise_code}")
                return
            
            # ƒê·ªçc n·ªôi dung XML
            with open(enterprise['xml_template'], 'r', encoding='utf-8') as f:
                xml_content = f.read()
            
            # T·∫°o c·ª≠a s·ªï hi·ªÉn th·ªã XML
            xml_window = tk.Toplevel(self.root)
            xml_window.title(f"üìÑ XML Template - {enterprise['name']} ({enterprise_code})")
            xml_window.geometry("900x700")
            
            # Frame th√¥ng tin
            info_frame = ttk.LabelFrame(xml_window, text="üìã Th√¥ng Tin Doanh Nghi·ªáp", padding=10)
            info_frame.pack(fill='x', padx=10, pady=5)
            
            ttk.Label(info_frame, text=f"üè¢ T√™n DN: {enterprise['name']}", font=('Arial', 10, 'bold')).pack(anchor='w')
            if 'mst' in enterprise:
                ttk.Label(info_frame, text=f"üî¢ MST: {enterprise['mst']}", font=('Arial', 10)).pack(anchor='w')
            ttk.Label(info_frame, text=f"üìÅ File: {enterprise['xml_template']}", font=('Arial', 10)).pack(anchor='w')
            
            # Frame n·ªôi dung XML
            xml_frame = ttk.LabelFrame(xml_window, text="üìÑ N·ªôi Dung XML Template", padding=10)
            xml_frame.pack(fill='both', expand=True, padx=10, pady=5)
            
            # Text widget v·ªõi scrollbar
            xml_text = tk.Text(xml_frame, wrap='none', font=('Consolas', 9))
            xml_scrollbar_y = ttk.Scrollbar(xml_frame, orient='vertical', command=xml_text.yview)
            xml_scrollbar_x = ttk.Scrollbar(xml_frame, orient='horizontal', command=xml_text.xview)
            xml_text.configure(yscrollcommand=xml_scrollbar_y.set, xscrollcommand=xml_scrollbar_x.set)
            
            xml_text.pack(side='left', fill='both', expand=True)
            xml_scrollbar_y.pack(side='right', fill='y')
            xml_scrollbar_x.pack(side='bottom', fill='x')
            
            # Hi·ªÉn th·ªã n·ªôi dung XML
            xml_text.insert('1.0', xml_content)
            xml_text.config(state='disabled')
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå L·ªói khi xem XML: {e}")
    
    def delete_enterprise(self, enterprise_code):
        """X√≥a doanh nghi·ªáp kh·ªèi danh s√°ch."""
        try:
            enterprise = self.enterprises.get(enterprise_code, {})
            
            # X√°c nh·∫≠n x√≥a
            confirm = messagebox.askyesno("X√°c nh·∫≠n x√≥a", 
                                        f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a doanh nghi·ªáp:\n\nüè¢ {enterprise.get('name', 'Unknown')} ({enterprise_code})\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!")
            
            if confirm:
                # X√≥a kh·ªèi danh s√°ch
                del self.enterprises[enterprise_code]
                
                # L∆∞u thay ƒë·ªïi
                self.save_enterprises()
                
                # L√†m m·ªõi GUI
                self.refresh_enterprises_list()
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ x√≥a doanh nghi·ªáp {enterprise_code}")
                
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå L·ªói khi x√≥a doanh nghi·ªáp: {e}")

def main():
    """H√†m ch√≠nh."""
    print(">> Khoi dong XML Protector - GUI Builder Tich Hop...")
    
    try:
        builder = XMLProtectorBuilder()
        builder.run()
    except Exception as e:
        print(f">> Loi khoi dong GUI: {e}")
        messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông GUI: {e}")

if __name__ == '__main__':
    main()

