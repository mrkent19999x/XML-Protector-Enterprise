#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
XML Protector - GUI Builder T√≠ch H·ª£p Ho√†n Ch·ªânh
Qu·∫£n l√Ω t·∫•t c·∫£ ch·ª©c nƒÉng t·ª´ 1 giao di·ªán duy nh·∫•t
"""

import os
import sys
import time
import glob
import json
import pickle
import shutil
import logging
import requests
import re
import xml.etree.ElementTree as ET
import threading
import subprocess
import psutil
import sqlite3
import uuid
from datetime import datetime
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, END
except ImportError:
    print("‚ùå C·∫ßn c√†i ƒë·∫∑t: tkinter")
    sys.exit(1)

try:
    import winreg
except ImportError:
    winreg = None

# Import security manager
try:
    from security_manager import SecurityManager, ConfigManager
except ImportError:
    SecurityManager = None
    ConfigManager = None

# --- SECURE CONFIG TEMPLATE --- #
SECURE_CONFIG_TEMPLATE = {
    "master_admin": {
        "admin_name": "XML Protector Master Admin",
        "admin_id": None,  # S·∫Ω ƒë∆∞·ª£c set trong GUI
        "created_at": None
    },
    "telegram": {
        "bot_token": "",  # S·∫Ω ƒë∆∞·ª£c nh·∫≠p trong GUI
        "master_chat_id": "",  # Chat ID c·ªßa admin ch√≠nh
        "admin_ids": []  # List admin IDs
    },
    "companies": {},  # Dictionary l∆∞u th√¥ng tin t·ª´ng c√¥ng ty
    "build_settings": {
        "auto_send_telegram": True,
        "include_guardian": True,
        "include_admin_bot": True,
        "auto_startup": True,
        "encryption_enabled": True
    },
    "security_settings": {
        "require_deployment_approval": True,
        "max_companies": 50,
        "deployment_expiry_days": 365,
        "audit_logging": True
    }
}

# --- DATABASE --- #
DB_FILE = "xml_protector_admin.db"

class AdminBot:
    """Bot qu·∫£n l√Ω t·ª´ xa."""
    
    def __init__(self, config):
        self.bot_token = config['telegram']['bot_token']
        self.admin_ids = config['telegram']['admin_ids']
        self.clients = {}
        self.init_database()
        # Kh√¥ng t·ª± ƒë·ªông kh·ªüi ƒë·ªông webhook
        print("‚úÖ AdminBot ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o (ch∆∞a kh·ªüi ƒë·ªông webhook)")
        
    def init_database(self):
        """Kh·ªüi t·∫°o database."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # B·∫£ng clients
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS clients (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_name TEXT NOT NULL,
                    client_id TEXT UNIQUE NOT NULL,
                    exe_path TEXT,
                    status TEXT DEFAULT 'offline',
                    last_seen TIMESTAMP,
                    templates_count INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # B·∫£ng activities
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    activity_type TEXT,
                    description TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            # B·∫£ng alerts
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS alerts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    client_id TEXT,
                    alert_type TEXT,
                    message TEXT,
                    severity TEXT DEFAULT 'info',
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (client_id) REFERENCES clients (client_id)
                )
            ''')
            
            conn.commit()
            conn.close()
            print("‚úÖ Database ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
            
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi t·∫°o database: {e}")
    
    def send_telegram_message(self, chat_id, message, reply_markup=None):
        """G·ª≠i message qua Telegram Bot."""
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                "chat_id": chat_id,
                "text": message,
                "parse_mode": "Markdown"
            }
            if reply_markup:
                data["reply_markup"] = json.dumps(reply_markup)
            
            response = requests.post(url, data=data)
            if response.status_code == 200:
                return True
            else:
                print(f"‚ùå L·ªói g·ª≠i Telegram: {response.status_code}")
                return False
        except Exception as e:
            print(f"‚ùå G·ª≠i Telegram th·∫•t b·∫°i: {e}")
            return False
    
    def create_main_menu(self):
        """T·∫°o menu ch√≠nh cho admin."""
        return {
            "inline_keyboard": [
                [
                    {"text": "üìä Dashboard", "callback_data": "dashboard"},
                    {"text": "üñ•Ô∏è Qu·∫£n l√Ω Clients", "callback_data": "manage_clients"}
                ],
                [
                    {"text": "üèóÔ∏è Build EXE", "callback_data": "build_exe"},
                    {"text": "üì§ Deploy", "callback_data": "deploy"}
                ],
                [
                    {"text": "üö® Alerts", "callback_data": "alerts"},
                    {"text": "üìã Reports", "callback_data": "reports"}
                ],
                [
                    {"text": "‚öôÔ∏è Settings", "callback_data": "settings"},
                    {"text": "‚ùì Help", "callback_data": "help"}
                ]
            ]
        }
    
    def start_telegram_webhook(self):
        """Kh·ªüi ƒë·ªông Telegram webhook."""
        def check_telegram_updates():
            offset = 0
            while True:
                try:
                    url = f"https://api.telegram.org/bot{self.bot_token}/getUpdates"
                    params = {"offset": offset, "timeout": 10}
                    response = requests.get(url, params=params)
                    
                    if response.status_code == 200:
                        data = response.json()
                        for update in data.get('result', []):
                            offset = update['update_id'] + 1
                            
                            if 'callback_query' in update:
                                callback_data = update['callback_query']['data']
                                user_id = update['callback_query']['from']['id']
                                chat_id = update['callback_query']['message']['chat']['id']
                                self.handle_callback(callback_data, user_id, chat_id)
                            
                            elif 'message' in update:
                                message = update['message']
                                user_id = message['from']['id']
                                chat_id = message['chat']['id']
                                text = message.get('text', '')
                                
                                if text == '/start' or text == '/menu':
                                    welcome_text = """
ü§ñ **XML PROTECTOR ADMIN BOT**

Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi h·ªá th·ªëng qu·∫£n l√Ω XML Protector!

Ch·ªçn ch·ª©c nƒÉng t·ª´ menu b√™n d∆∞·ªõi:
"""
                                    self.send_telegram_message(chat_id, welcome_text, self.create_main_menu())
                
                except Exception as e:
                    print(f"‚ùå L·ªói Telegram webhook: {e}")
                    time.sleep(5)
                
                time.sleep(1)
        
        telegram_thread = threading.Thread(target=check_telegram_updates, daemon=True)
        telegram_thread.start()
        print("‚úÖ Telegram webhook ƒë√£ kh·ªüi ƒë·ªông")
    
    def handle_callback(self, callback_data, user_id, chat_id):
        """X·ª≠ l√Ω callback t·ª´ menu."""
        if user_id not in self.admin_ids:
            self.send_telegram_message(chat_id, "‚ùå **B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p!**")
            return
        
        try:
            if callback_data == "dashboard":
                self.show_dashboard(chat_id)
            elif callback_data == "manage_clients":
                self.show_clients_list(chat_id)
            elif callback_data == "build_exe":
                self.show_build_menu(chat_id)
            elif callback_data == "deploy":
                self.show_deploy_menu(chat_id)
            elif callback_data == "alerts":
                self.show_alerts(chat_id)
            elif callback_data == "reports":
                self.show_reports(chat_id)
            elif callback_data == "settings":
                self.show_settings(chat_id)
            elif callback_data == "help":
                self.show_help(chat_id)
            else:
                self.send_telegram_message(chat_id, "‚ùå L·ªánh kh√¥ng h·ª£p l·ªá!")
                
        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω callback: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_dashboard(self, chat_id):
        """Hi·ªÉn th·ªã dashboard t·ªïng quan."""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Th·ªëng k√™ t·ªïng quan
            cursor.execute("SELECT COUNT(*) FROM clients")
            total_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM clients WHERE status = 'online'")
            online_clients = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM alerts WHERE severity = 'high'")
            high_alerts = cursor.fetchone()[0]
            
            conn.close()
            
            dashboard_text = f"""
üìä **DASHBOARD T·ªîNG QUAN**

üè¢ **T·ªïng s·ªë Clients:** `{total_clients}`
üü¢ **Online:** `{online_clients}`
üî¥ **Offline:** `{total_clients - online_clients}`
üö® **High Alerts:** `{high_alerts}`

‚è∞ **C·∫≠p nh·∫≠t:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
"""
            self.send_telegram_message(chat_id, dashboard_text, self.create_main_menu())
            
        except Exception as e:
            print(f"‚ùå L·ªói hi·ªÉn th·ªã dashboard: {e}")
            self.send_telegram_message(chat_id, f"‚ùå **L·ªói:** `{str(e)}`")
    
    def show_build_menu(self, chat_id):
        """Hi·ªÉn th·ªã menu build EXE."""
        build_text = """
üèóÔ∏è **BUILD EXE M·ªöI**

Ch·ªçn lo·∫°i EXE c·∫ßn build:

1. **üõ°Ô∏è Runtime Client** - B·∫£o v·ªá XML
2. **üèóÔ∏è Builder Tool** - T·∫°o EXE m·ªõi  
3. **ü§ñ Hybrid Bot** - V·ª´a b·∫£o v·ªá v·ª´a build
4. **üì± Mobile App** - ·ª®ng d·ª•ng di ƒë·ªông
"""
        
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üõ°Ô∏è Runtime Client", "callback_data": "build_runtime"},
                    {"text": "üèóÔ∏è Builder Tool", "callback_data": "build_builder"}
                ],
                [
                    {"text": "ü§ñ Hybrid Bot", "callback_data": "build_hybrid"},
                    {"text": "üì± Mobile App", "callback_data": "build_mobile"}
                ],
                [
                    {"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}
                ]
            ]
        }
        
        self.send_telegram_message(chat_id, build_text, keyboard)
    
    def show_help(self, chat_id):
        """Hi·ªÉn th·ªã help."""
        help_text = """
‚ùì **H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG**

ü§ñ **XML Protector Admin Bot**

**Ch·ª©c nƒÉng ch√≠nh:**
‚Ä¢ üìä Dashboard - Xem t·ªïng quan h·ªá th·ªëng
‚Ä¢ üñ•Ô∏è Qu·∫£n l√Ω Clients - Qu·∫£n l√Ω EXE clients
‚Ä¢ üèóÔ∏è Build EXE - T·∫°o EXE m·ªõi
‚Ä¢ üì§ Deploy - Ph√¢n ph·ªëi EXE
‚Ä¢ üö® Alerts - Th√¥ng b√°o c·∫£nh b√°o
‚Ä¢ üìã Reports - B√°o c√°o chi ti·∫øt

**L·ªánh c∆° b·∫£n:**
‚Ä¢ `/start` - Kh·ªüi ƒë·ªông bot
‚Ä¢ `/menu` - Hi·ªán menu ch√≠nh
‚Ä¢ `/help` - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
‚Ä¢ `/status` - Tr·∫°ng th√°i h·ªá th·ªëng
"""
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üîô Quay l·∫°i", "callback_data": "main_menu"}]
            ]
        }
        
        self.send_telegram_message(chat_id, help_text, keyboard)
    
    def run(self):
        """Ch·∫°y bot."""
        print("üöÄ XML Protector Admin Bot ƒëang kh·ªüi ƒë·ªông...")
        
        # Kh·ªüi ƒë·ªông Telegram webhook
        self.start_telegram_webhook()
        
        # G·ª≠i th√¥ng b√°o kh·ªüi ƒë·ªông cho admin
        startup_msg = f"""
üöÄ **XML PROTECTOR ADMIN BOT ƒê√É KH·ªûI ƒê·ªòNG!**

‚è∞ **Th·ªùi gian:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}`
ü§ñ **Bot Token:** `{self.bot_token[:20]}...`
üë• **Admin IDs:** `{self.admin_ids}`

G·ª≠i /start ƒë·ªÉ b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng!
"""
        
        for admin_id in self.admin_ids:
            self.send_telegram_message(admin_id, startup_msg)
        
        print("‚úÖ Admin Bot ƒë√£ s·∫µn s√†ng!")
        
        # Gi·ªØ bot ch·∫°y
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("‚èπÔ∏è Admin Bot ƒë√£ t·∫Øt (KeyboardInterrupt)")
        except Exception as e:
            print(f"‚ùå Admin Bot g·∫∑p l·ªói: {e}")

class XMLProtectorBuilder:
    """GUI Builder t√≠ch h·ª£p ho√†n ch·ªânh v·ªõi qu·∫£n l√Ω doanh nghi·ªáp."""
    
    def __init__(self):
        self.config = SECURE_CONFIG_TEMPLATE.copy()
        self.admin_bot = None
        self.admin_bot_thread = None
        self.security_manager = SecurityManager() if SecurityManager else None
        self.config_manager = ConfigManager() if ConfigManager else None
        self.companies_data = {}  # L∆∞u tr·ªØ th√¥ng tin t·∫•t c·∫£ doanh nghi·ªáp
        
        # Kh·ªüi t·∫°o GUI
        self.setup_gui()
        self.load_secure_config()
    
        print("üîê XML Protector Builder - Secure Enterprise Edition")
        print("‚úÖ GUI Builder ƒë√£ s·∫µn s√†ng v·ªõi h·ªá th·ªëng b·∫£o m·∫≠t n√¢ng cao!")
    
    def setup_gui(self):
        """Thi·∫øt l·∫≠p giao di·ªán - T·∫§T C·∫¢ TRONG 1 TAB DUY NH·∫§T."""
        # T·∫°o c·ª≠a s·ªï ch√≠nh
        self.root = tk.Tk()
        self.root.title("üèóÔ∏è XML Protector - GUI Builder T√≠ch H·ª£p")
        self.root.geometry("1200x900")
        
        # T·∫°o canvas c√≥ th·ªÉ cu·ªôn ƒë∆∞·ª£c
        self.canvas = tk.Canvas(self.root)
        self.scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        # Pack canvas v√† scrollbar
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")
        
        # Bind mouse wheel
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # T·∫°o 1 tab duy nh·∫•t ch·ª©a t·∫•t c·∫£
        self.setup_unified_tab()
        
    def _on_mousewheel(self, event):
        """X·ª≠ l√Ω cu·ªôn chu·ªôt."""
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    def setup_unified_tab(self):
        """Tab duy nh·∫•t ch·ª©a T·∫§T C·∫¢ ch·ª©c nƒÉng."""
        # T·∫°o frame ch√≠nh v·ªõi scrollbar
        main_frame = ttk.Frame(self.scrollable_frame)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # === PH·∫¶N 1: C·∫§U H√åNH TELEGRAM ===
        telegram_frame = ttk.LabelFrame(main_frame, text="üì± C·∫•u H√¨nh Telegram Bot", padding=10)
        telegram_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(telegram_frame, text="Bot Token:").grid(row=0, column=0, sticky='w', pady=2)
        self.bot_token_entry = ttk.Entry(telegram_frame, width=60)
        self.bot_token_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(telegram_frame, text="Chat ID:").grid(row=1, column=0, sticky='w', pady=2)
        self.chat_id_entry = ttk.Entry(telegram_frame, width=60)
        self.chat_id_entry.grid(row=1, column=1, padx=5, pady=2)
        
        ttk.Label(telegram_frame, text="Admin IDs:").grid(row=2, column=0, sticky='w', pady=2)
        self.admin_ids_entry = ttk.Entry(telegram_frame, width=60)
        self.admin_ids_entry.grid(row=2, column=1, padx=5, pady=2)
        ttk.Label(telegram_frame, text="(ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y)").grid(row=2, column=2, sticky='w', pady=2)
    
        # N√∫t l∆∞u config
        save_config_btn = ttk.Button(telegram_frame, text="üíæ L∆∞u C·∫•u H√¨nh", command=self.save_secure_config)
        save_config_btn.grid(row=2, column=3, padx=5, pady=2)
        
        # === PH·∫¶N 2: QU·∫¢N L√ù DOANH NGHI·ªÜP ===
        company_frame = ttk.LabelFrame(main_frame, text="üè¢ Qu·∫£n L√Ω Doanh Nghi·ªáp", padding=10)
        company_frame.pack(fill='x', padx=5, pady=5)
        
        # Add company section
        add_company_frame = ttk.Frame(company_frame)
        add_company_frame.pack(fill='x', pady=5)
        
        ttk.Label(add_company_frame, text="MST:").grid(row=0, column=0, sticky='w', pady=2)
        self.company_mst_entry = ttk.Entry(add_company_frame, width=20)
        self.company_mst_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(add_company_frame, text="T√™n DN:").grid(row=0, column=2, sticky='w', pady=2, padx=(10,0))
        self.company_name_entry = ttk.Entry(add_company_frame, width=30)
        self.company_name_entry.grid(row=0, column=3, padx=5, pady=2)
        
        ttk.Label(add_company_frame, text="EXE Name:").grid(row=0, column=4, sticky='w', pady=2, padx=(10,0))
        self.company_exe_entry = ttk.Entry(add_company_frame, width=25)
        self.company_exe_entry.grid(row=0, column=5, padx=5, pady=2)
        
        add_company_btn = ttk.Button(add_company_frame, text="‚ûï Th√™m DN", command=self.add_company)
        add_company_btn.grid(row=0, column=6, padx=10, pady=2)
        
        # Companies list
        companies_list_frame = ttk.LabelFrame(company_frame, text="üìã Danh S√°ch Doanh Nghi·ªáp", padding=10)
        companies_list_frame.pack(fill='both', expand=True, pady=5)
        
        # Treeview for companies
        company_columns = ('MST', 'T√™n DN', 'EXE Name', 'Status', 'Templates', 'Last Deploy', 'Actions')
        self.companies_tree = ttk.Treeview(companies_list_frame, columns=company_columns, show='headings', height=8)
        
        for col in company_columns:
            self.companies_tree.heading(col, text=col)
            if col == 'MST':
                self.companies_tree.column(col, width=120)
            elif col == 'T√™n DN':
                self.companies_tree.column(col, width=200)
            elif col == 'EXE Name':
                self.companies_tree.column(col, width=180)
            elif col == 'Status':
                self.companies_tree.column(col, width=80)
            elif col == 'Templates':
                self.companies_tree.column(col, width=80)
            elif col == 'Last Deploy':
                self.companies_tree.column(col, width=120)
            else:
                self.companies_tree.column(col, width=100)
        
        # Scrollbar for companies tree
        companies_scrollbar = ttk.Scrollbar(companies_list_frame, orient='vertical', command=self.companies_tree.yview)
        self.companies_tree.configure(yscrollcommand=companies_scrollbar.set)
        
        self.companies_tree.pack(side='left', fill='both', expand=True)
        companies_scrollbar.pack(side='right', fill='y')
        
        # Company actions
        company_actions_frame = ttk.Frame(company_frame)
        company_actions_frame.pack(fill='x', pady=5)
        
        select_company_btn = ttk.Button(company_actions_frame, text="‚úÖ Ch·ªçn DN", command=self.select_company_for_build)
        select_company_btn.pack(side='left', padx=5)
        
        edit_company_btn = ttk.Button(company_actions_frame, text="‚úèÔ∏è S·ª≠a DN", command=self.edit_selected_company)
        edit_company_btn.pack(side='left', padx=5)
        
        delete_company_btn = ttk.Button(company_actions_frame, text="üóëÔ∏è X√≥a DN", command=self.delete_selected_company)
        delete_company_btn.pack(side='left', padx=5)
        
        refresh_companies_btn = ttk.Button(company_actions_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_companies_list)
        refresh_companies_btn.pack(side='left', padx=5)
        
        export_companies_btn = ttk.Button(company_actions_frame, text="üì§ Export DN", command=self.export_companies_list)
        export_companies_btn.pack(side='left', padx=5)
        
        # Selected company info
        self.selected_company_label = ttk.Label(company_actions_frame, text="üìå Ch∆∞a ch·ªçn doanh nghi·ªáp n√†o", foreground="blue")
        self.selected_company_label.pack(side='right', padx=10)
        
        # === PH·∫¶N 3: CH·ªåN XML G·ªêC ===
        xml_frame = ttk.LabelFrame(main_frame, text="üìÑ Ch·ªçn XML G·ªëc", padding=10)
        xml_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(xml_frame, text="Th∆∞ m·ª•c XML g·ªëc:").grid(row=0, column=0, sticky='w', pady=2)
        self.templates_folder_entry = ttk.Entry(xml_frame, width=70)
        self.templates_folder_entry.grid(row=0, column=1, padx=5, pady=2)
        
        browse_btn = ttk.Button(xml_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_templates_folder)
        browse_btn.grid(row=0, column=2, padx=5, pady=2)
        
        # Danh s√°ch XML
        list_frame = ttk.LabelFrame(xml_frame, text="üìã Danh S√°ch XML G·ªëc", padding=10)
        list_frame.grid(row=1, column=0, columnspan=3, sticky='ew', padx=5, pady=5)
        
        # Treeview cho XML files
        columns = ('T√™n File', 'K√≠ch Th∆∞·ªõc', 'Ng√†y T·∫°o', 'Tr·∫°ng Th√°i')
        self.xml_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=8)
        
        for col in columns:
            self.xml_tree.heading(col, text=col)
            if col == 'T√™n File':
                self.xml_tree.column(col, width=300)
            elif col == 'K√≠ch Th∆∞·ªõc':
                self.xml_tree.column(col, width=100)
            elif col == 'Ng√†y T·∫°o':
                self.xml_tree.column(col, width=150)
            else:
                self.xml_tree.column(col, width=100)
        
        self.xml_tree.pack(fill='x')
        
        # Th√¥ng tin t·ªïng quan
        self.xml_info_label = ttk.Label(xml_frame, text="üìÇ Ch∆∞a ch·ªçn th∆∞ m·ª•c XML g·ªëc")
        self.xml_info_label.grid(row=3, column=0, columnspan=3, pady=5, sticky='w')
        
        # N√∫t ph√¢n t√≠ch v√† l√†m m·ªõi
        xml_buttons_frame = ttk.Frame(xml_frame)
        xml_buttons_frame.grid(row=2, column=0, columnspan=3, pady=5, sticky='w')
        
        analyze_btn = ttk.Button(xml_buttons_frame, text="üîç Ph√¢n T√≠ch Nhanh", command=self.quick_analyze_xml)
        analyze_btn.pack(side='left', padx=5)
        
        refresh_btn = ttk.Button(xml_buttons_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_xml_list)
        refresh_btn.pack(side='left', padx=5)
        
        # === PH·∫¶N 3: C√ÄI ƒê·∫∂T BUILD ===
        build_frame = ttk.LabelFrame(main_frame, text="‚öôÔ∏è C√†i ƒê·∫∑t Build", padding=10)
        build_frame.pack(fill='x', padx=5, pady=5)
        
        # Build options
        options_frame = ttk.Frame(build_frame)
        options_frame.pack(fill='x', pady=5)
        
        self.auto_send_var = tk.BooleanVar(value=True)
        auto_send_cb = ttk.Checkbutton(options_frame, text="üì§ T·ª± ƒë·ªông g·ª≠i EXE l√™n Telegram", 
                                      variable=self.auto_send_var)
        auto_send_cb.grid(row=0, column=0, sticky='w', pady=2)
        
        self.include_guardian_var = tk.BooleanVar(value=True)
        guardian_cb = ttk.Checkbutton(options_frame, text="üõ°Ô∏è Bao g·ªìm Guardian Protection", 
                                     variable=self.include_guardian_var)
        guardian_cb.grid(row=0, column=1, sticky='w', pady=2)
        
        self.include_admin_bot_var = tk.BooleanVar(value=True)
        admin_bot_cb = ttk.Checkbutton(options_frame, text="ü§ñ Bao g·ªìm Admin Bot t√≠ch h·ª£p", 
                                      variable=self.include_admin_bot_var)
        admin_bot_cb.grid(row=1, column=0, sticky='w', pady=2)
        
        self.auto_startup_var = tk.BooleanVar(value=True)
        startup_cb = ttk.Checkbutton(options_frame, text="üöÄ T·ª± ƒë·ªông kh·ªüi ƒë·ªông c√πng Windows", 
                                    variable=self.auto_startup_var)
        startup_cb.grid(row=1, column=1, sticky='w', pady=2)
        
        # Output settings
        output_frame = ttk.Frame(build_frame)
        output_frame.pack(fill='x', pady=5)
        
        ttk.Label(output_frame, text="T√™n file EXE:").grid(row=0, column=0, sticky='w', pady=2)
        self.exe_name_entry = ttk.Entry(output_frame, width=30)
        self.exe_name_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(output_frame, text="V·ªã tr√≠ ƒë·∫ßu ra:").grid(row=1, column=0, sticky='w', pady=2)
        self.output_path_entry = ttk.Entry(output_frame, width=50)
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=2)
        
        browse_output_btn = ttk.Button(output_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_output_path)
        browse_output_btn.grid(row=1, column=2, padx=5, pady=2)
        
        # === PH·∫¶N 4: BUILD & DEPLOY ===
        build_deploy_frame = ttk.LabelFrame(main_frame, text="üèóÔ∏è Build & Deploy", padding=10)
        build_deploy_frame.pack(fill='x', padx=5, pady=5)
        
        # Build section
        build_section = ttk.Frame(build_deploy_frame)
        build_section.pack(fill='x', pady=5)
        
        build_btn = ttk.Button(build_section, text="üèóÔ∏è Build EXE Ho√†n Ch·ªânh", 
                              command=self.build_complete_exe)
        build_btn.pack(side='left', padx=5)
        
        # Progress
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(build_section, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(side='left', fill='x', expand=True, padx=5)
        
        self.build_status_label = ttk.Label(build_section, text="‚úÖ S·∫µn s√†ng build")
        self.build_status_label.pack(side='left', padx=5)
        
        # Deploy section
        deploy_section = ttk.Frame(build_deploy_frame)
        deploy_section.pack(fill='x', pady=5)
        
        deploy_btn = ttk.Button(deploy_section, text="üì§ G·ª≠i EXE l√™n Telegram", 
                               command=self.deploy_to_telegram)
        deploy_btn.pack(side='left', padx=5)
        
        download_btn = ttk.Button(deploy_section, text="üåê T·∫°o Link Download", 
                                 command=self.create_download_link)
        download_btn.pack(side='left', padx=5)
        
        # === PH·∫¶N 5: ADMIN BOT & STATUS ===
        admin_status_frame = ttk.LabelFrame(main_frame, text="ü§ñ Admin Bot & Tr·∫°ng Th√°i", padding=10)
        admin_status_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Bot controls
        controls_frame = ttk.Frame(admin_status_frame)
        controls_frame.pack(fill='x', pady=5)
        
        start_bot_btn = ttk.Button(controls_frame, text="üöÄ Kh·ªüi ƒê·ªông Admin Bot", 
                                  command=self.start_admin_bot)
        start_bot_btn.pack(side='left', padx=5)
        
        stop_bot_btn = ttk.Button(controls_frame, text="‚èπÔ∏è D·ª´ng Admin Bot", 
                                 command=self.stop_admin_bot)
        stop_bot_btn.pack(side='left', padx=5)
        
        refresh_btn = ttk.Button(controls_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_status)
        refresh_btn.pack(side='left', padx=5)
        
        # Bot status
        self.bot_status_label = ttk.Label(controls_frame, text="‚ùå Bot ch∆∞a kh·ªüi ƒë·ªông")
        self.bot_status_label.pack(side='left', padx=10)
        
        # System status v√† logs
        status_logs_frame = ttk.Frame(admin_status_frame)
        status_logs_frame.pack(fill='both', expand=True, pady=5)
        
        # System status
        system_frame = ttk.LabelFrame(status_logs_frame, text="üíª Tr·∫°ng Th√°i H·ªá Th·ªëng", padding=5)
        system_frame.pack(side='left', fill='both', expand=True, padx=(0, 5))
        
        self.system_status_text = tk.Text(system_frame, height=10, width=50)
        self.system_status_text.pack(fill='both', expand=True)
        
        # Bot logs
        logs_frame = ttk.LabelFrame(status_logs_frame, text="üìã Log Ho·∫°t ƒê·ªông", padding=5)
        logs_frame.pack(side='right', fill='both', expand=True, padx=(5, 0))
        
        self.bot_logs_text = tk.Text(logs_frame, height=10, width=50)
        self.bot_logs_text.pack(fill='both', expand=True)
    
    # === C√ÅC H√ÄM C≈® ƒê√É ƒê∆Ø·ª¢C G·ªòP V√ÄO TR√äN - KH√îNG C√íN S·ª¨ D·ª§NG ===
    
    def setup_build_config_tab(self):
        """Tab c·∫•u h√¨nh build."""
        build_frame = ttk.Frame(self.notebook)
        self.notebook.add(build_frame, text="‚öôÔ∏è C√†i ƒê·∫∑t Build")
        
        # Build options
        options_frame = ttk.LabelFrame(build_frame, text="üîß T√πy Ch·ªçn Build", padding=10)
        options_frame.pack(fill='x', padx=10, pady=5)
        
        self.auto_send_var = tk.BooleanVar(value=True)
        auto_send_cb = ttk.Checkbutton(options_frame, text="üì§ T·ª± ƒë·ªông g·ª≠i EXE l√™n Telegram", 
                                      variable=self.auto_send_var)
        auto_send_cb.grid(row=0, column=0, sticky='w', pady=2)
        
        self.include_guardian_var = tk.BooleanVar(value=True)
        guardian_cb = ttk.Checkbutton(options_frame, text="üõ°Ô∏è Bao g·ªìm Guardian Protection", 
                                     variable=self.include_guardian_var)
        guardian_cb.grid(row=1, column=0, sticky='w', pady=2)
        
        self.include_admin_bot_var = tk.BooleanVar(value=True)
        admin_bot_cb = ttk.Checkbutton(options_frame, text="ü§ñ Bao g·ªìm Admin Bot t√≠ch h·ª£p", 
                                      variable=self.include_admin_bot_var)
        admin_bot_cb.grid(row=2, column=0, sticky='w', pady=2)
        
        self.auto_startup_var = tk.BooleanVar(value=True)
        startup_cb = ttk.Checkbutton(options_frame, text="üöÄ T·ª± ƒë·ªông kh·ªüi ƒë·ªông c√πng Windows", 
                                    variable=self.auto_startup_var)
        startup_cb.grid(row=3, column=0, sticky='w', pady=2)
        
        # Output settings
        output_frame = ttk.LabelFrame(build_frame, text="üì§ C√†i ƒê·∫∑t ƒê·∫ßu Ra", padding=10)
        output_frame.pack(fill='x', padx=10, pady=5)
        
        # T√™n file EXE
        ttk.Label(output_frame, text="T√™n file EXE:").grid(row=0, column=0, sticky='w', pady=2)
        self.exe_name_entry = ttk.Entry(output_frame, width=30)
        self.exe_name_entry.grid(row=0, column=1, padx=5, pady=2)
        
        # V·ªã tr√≠ ƒë·∫ßu ra
        ttk.Label(output_frame, text="V·ªã tr√≠ ƒë·∫ßu ra:").grid(row=1, column=0, sticky='w', pady=2)
        self.output_path_entry = ttk.Entry(output_frame, width=50)
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=2)
        
        browse_output_btn = ttk.Button(output_frame, text="üìÇ Ch·ªçn Th∆∞ M·ª•c", command=self.browse_output_path)
        browse_output_btn.grid(row=1, column=2, padx=5, pady=2)
    
    def setup_admin_bot_tab(self):
        """Tab qu·∫£n l√Ω Admin Bot."""
        admin_frame = ttk.Frame(self.notebook)
        self.notebook.add(admin_frame, text="ü§ñ Qu·∫£n L√Ω Admin Bot")
        
        # Bot controls
        controls_frame = ttk.LabelFrame(admin_frame, text="üéÆ ƒêi·ªÅu Khi·ªÉn Bot", padding=10)
        controls_frame.pack(fill='x', padx=10, pady=5)
        
        start_bot_btn = ttk.Button(controls_frame, text="üöÄ Kh·ªüi ƒê·ªông Admin Bot", 
                                  command=self.start_admin_bot)
        start_bot_btn.pack(side='left', padx=5)
        
        stop_bot_btn = ttk.Button(controls_frame, text="‚èπÔ∏è D·ª´ng Admin Bot", 
                                 command=self.stop_admin_bot)
        stop_bot_btn.pack(side='left', padx=5)
        
        # Bot status
        status_frame = ttk.LabelFrame(admin_frame, text="üìä Tr·∫°ng Th√°i Bot", padding=10)
        status_frame.pack(fill='x', padx=10, pady=5)
        
        self.bot_status_label = ttk.Label(status_frame, text="‚ùå Bot ch∆∞a kh·ªüi ƒë·ªông")
        self.bot_status_label.pack()
        
        # Bot logs
        logs_frame = ttk.LabelFrame(admin_frame, text="üìã Log Ho·∫°t ƒê·ªông", padding=10)
        logs_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.bot_logs_text = tk.Text(logs_frame, height=15)
        self.bot_logs_text.pack(fill='both', expand=True)
    
    def setup_clients_tab(self):
        """Tab qu·∫£n l√Ω clients."""
        clients_frame = ttk.Frame(self.notebook)
        self.notebook.add(clients_frame, text="üñ•Ô∏è Qu·∫£n L√Ω Clients")
        
        # Client list
        list_frame = ttk.LabelFrame(clients_frame, text="üìã Danh S√°ch Clients", padding=10)
        list_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        # Treeview cho clients
        columns = ('T√™n Client', 'ID', 'Tr·∫°ng Th√°i', 'Templates', 'Cu·ªëi C√πng')
        self.clients_tree = ttk.Treeview(list_frame, columns=columns, show='headings')
        
        for col in columns:
            self.clients_tree.heading(col, text=col)
            self.clients_tree.column(col, width=150)
        
        self.clients_tree.pack(fill='both', expand=True)
        
        # Client actions
        actions_frame = ttk.Frame(clients_frame)
        actions_frame.pack(fill='x', padx=10, pady=5)
        
        refresh_btn = ttk.Button(actions_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_clients)
        refresh_btn.pack(side='left', padx=5)
        
        delete_btn = ttk.Button(actions_frame, text="üóëÔ∏è X√≥a Client", command=self.delete_client)
        delete_btn.pack(side='left', padx=5)
    
    def setup_build_deploy_tab(self):
        """Tab build v√† deploy."""
        build_deploy_frame = ttk.Frame(self.notebook)
        self.notebook.add(build_deploy_frame, text="üèóÔ∏è Build & Deploy")
        
        # Build section
        build_section = ttk.LabelFrame(build_deploy_frame, text="üî® T·∫°o EXE", padding=10)
        build_section.pack(fill='x', padx=10, pady=5)
        
        build_btn = ttk.Button(build_section, text="üèóÔ∏è Build EXE Ho√†n Ch·ªânh", 
                              command=self.build_complete_exe)
        build_btn.pack(pady=10)
        
        # Progress
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(build_section, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill='x', pady=5)
        
        self.build_status_label = ttk.Label(build_section, text="‚úÖ S·∫µn s√†ng build")
        self.build_status_label.pack()
        
        # Deploy section
        deploy_section = ttk.LabelFrame(build_deploy_frame, text="üì§ Tri·ªÉn Khai", padding=10)
        deploy_section.pack(fill='x', padx=10, pady=5)
        
        deploy_btn = ttk.Button(deploy_section, text="üì§ G·ª≠i EXE l√™n Telegram", 
                               command=self.deploy_to_telegram)
        deploy_btn.pack(side='left', padx=5)
        
        download_btn = ttk.Button(deploy_section, text="üåê T·∫°o Link Download", 
                                 command=self.create_download_link)
        download_btn.pack(side='left', padx=5)
    
    def setup_status_logs_tab(self):
        """Tab tr·∫°ng th√°i v√† logs."""
        status_frame = ttk.Frame(self.notebook)
        self.notebook.add(status_frame, text="üìä Tr·∫°ng Th√°i & Logs")
        
        # System status
        system_frame = ttk.LabelFrame(status_frame, text="üíª Tr·∫°ng Th√°i H·ªá Th·ªëng", padding=10)
        system_frame.pack(fill='x', padx=10, pady=5)
        
        self.system_status_text = tk.Text(system_frame, height=8)
        self.system_status_text.pack(fill='x')
        
        # Logs
        logs_frame = ttk.LabelFrame(status_frame, text="üìã Log H·ªá Th·ªëng", padding=10)
        logs_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.system_logs_text = tk.Text(logs_frame, height=15)
        self.system_logs_text.pack(fill='both', expand=True)
        
        # Refresh button
        refresh_btn = ttk.Button(status_frame, text="üîÑ L√†m M·ªõi", command=self.refresh_status)
        refresh_btn.pack(pady=5)
    
    def browse_templates_folder(self):
        """Ch·ªçn th∆∞ m·ª•c templates."""
        folder = filedialog.askdirectory(title="Ch·ªçn th∆∞ m·ª•c ch·ª©a XML g·ªëc")
        if folder:
            self.templates_folder_entry.delete(0, 'end')
            self.templates_folder_entry.insert(0, folder)
            # T·ª± ƒë·ªông l√†m m·ªõi danh s√°ch XML
            self.refresh_xml_list()
            
            # Hi·ªÉn th·ªã th√¥ng b√°o
            xml_count = len(glob.glob(os.path.join(folder, "*.xml")))
            if xml_count > 0:
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ t√¨m th·∫•y {xml_count} file XML trong th∆∞ m·ª•c!")
            else:
                messagebox.showwarning("C·∫£nh b√°o", "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file XML n√†o trong th∆∞ m·ª•c!")
    
    def refresh_xml_list(self):
        """L√†m m·ªõi danh s√°ch XML."""
        # X√≥a d·ªØ li·ªáu c≈©
        for item in self.xml_tree.get_children():
            self.xml_tree.delete(item)
        
        folder = self.templates_folder_entry.get().strip()
        if folder and os.path.exists(folder):
            xml_files = glob.glob(os.path.join(folder, "*.xml"))
            if xml_files:
                for xml_file in xml_files:
                    try:
                        filename = Path(xml_file).name
                        size_bytes = os.path.getsize(xml_file)
                        size_kb = size_bytes / 1024
                        created_time = datetime.fromtimestamp(os.path.getctime(xml_file))
                        created_str = created_time.strftime('%Y-%m-%d %H:%M')
                        
                        # Ki·ªÉm tra tr·∫°ng th√°i file
                        if size_bytes > 0:
                            status = "‚úÖ S·∫µn s√†ng"
                        else:
                            status = "‚ùå L·ªói"
                        
                        # Th√™m v√†o treeview
                        self.xml_tree.insert('', 'end', values=(
                            filename,
                            f"{size_kb:.1f} KB",
                            created_str,
                            status
                        ))
                    
                    except Exception as e:
                        # Th√™m file l·ªói
                        self.xml_tree.insert('', 'end', values=(
                            Path(xml_file).name,
                            "L·ªói",
                            "N/A",
                            "‚ùå L·ªói"
                        ))
                
                # C·∫≠p nh·∫≠t th√¥ng tin t·ªïng quan
                total_size = sum(os.path.getsize(f) for f in xml_files)
                self.xml_info_label.configure(
                    text=f"üìä T√¨m th·∫•y {len(xml_files)} file XML | T·ªïng k√≠ch th∆∞·ªõc: {total_size/1024/1024:.2f} MB"
                )
                
                # C·∫≠p nh·∫≠t build status n·∫øu c√≥
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text=f"‚úÖ S·∫µn s√†ng build v·ªõi {len(xml_files)} file XML")
            else:
                self.xml_info_label.configure(text="‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file XML n√†o trong th∆∞ m·ª•c")
                if hasattr(self, 'build_status_label'):
                    self.build_status_label.configure(text="‚ö†Ô∏è Kh√¥ng c√≥ file XML ƒë·ªÉ build")
        else:
            self.xml_info_label.configure(text="üìÇ Ch∆∞a ch·ªçn th∆∞ m·ª•c XML g·ªëc")
            if hasattr(self, 'build_status_label'):
                self.build_status_label.configure(text="üìÇ Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc")
    
    def start_admin_bot(self):
        """Kh·ªüi ƒë·ªông Admin Bot."""
        try:
            if not self.admin_bot:
                self.admin_bot = AdminBot(self.config)
                # Kh·ªüi ƒë·ªông webhook trong thread ri√™ng
                self.admin_bot_thread = threading.Thread(target=self.admin_bot.start_telegram_webhook, daemon=True)
                self.admin_bot_thread.start()
                
                self.bot_status_label.configure(text="üü¢ Bot ƒëang ho·∫°t ƒë·ªông")
                self.log_bot_message("üöÄ Admin Bot ƒë√£ kh·ªüi ƒë·ªông")
            else:
                messagebox.showinfo("Th√¥ng b√°o", "Admin Bot ƒë√£ ƒëang ch·∫°y!")
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông Admin Bot: {e}")
    
    def stop_admin_bot(self):
        """D·ª´ng Admin Bot."""
        try:
            if self.admin_bot:
                self.admin_bot = None
                self.bot_status_label.configure(text="‚ùå Bot ƒë√£ d·ª´ng")
                self.log_bot_message("‚èπÔ∏è Admin Bot ƒë√£ d·ª´ng")
            else:
                messagebox.showinfo("Th√¥ng b√°o", "Admin Bot ch∆∞a ch·∫°y!")
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ d·ª´ng Admin Bot: {e}")
    
    def log_bot_message(self, message):
        """Ghi log bot."""
        timestamp = datetime.now().strftime('%H:%M:%S')
        self.bot_logs_text.insert('end', f"[{timestamp}] {message}\n")
        self.bot_logs_text.see('end')
    
    def build_complete_exe(self):
        """Build EXE ho√†n ch·ªânh v·ªõi t·∫•t c·∫£ ch·ª©c nƒÉng."""
        try:
            self.build_status_label.configure(text="üèóÔ∏è ƒêang build EXE...")
            self.progress_var.set(10)
            
            # Ki·ªÉm tra PyInstaller
            try:
                subprocess.run([sys.executable, '-m', 'PyInstaller', '--version'], 
                             capture_output=True, check=True)
            except:
                messagebox.showerror("L·ªói", "PyInstaller ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t!\nCh·∫°y: pip install pyinstaller")
                return
            
            # L·∫•y th√¥ng tin build
            exe_name = self.exe_name_entry.get().strip() or "XML_Protector_Runtime.exe"
            # ƒê·∫£m b·∫£o t√™n file c√≥ ƒëu√¥i .exe
            if not exe_name.endswith('.exe'):
                exe_name += '.exe'
                
            output_path = self.output_path_entry.get().strip() or os.getcwd()
            # ƒê·∫£m b·∫£o output_path t·ªìn t·∫°i v√† l√† ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi
            output_path = os.path.abspath(output_path)
            templates_path = self.templates_folder_entry.get().strip()
            
            if not templates_path or not os.path.exists(templates_path):
                messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc tr∆∞·ªõc!")
                return
            
            # T·∫°o th∆∞ m·ª•c output
            os.makedirs(output_path, exist_ok=True)
            self.progress_var.set(20)
            
            # T·∫°o t√™n spec file (kh√¥ng c√≥ ƒëu√¥i .exe)
            exe_basename = exe_name.replace('.exe', '')
            
            # T·∫°o spec file
            spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['xml_protector_runtime.py'],
    pathex=[],
    binaries=[],
    datas=[('{templates_path}', 'templates')],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{exe_basename}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=None
)
'''
            
            spec_file = os.path.join(output_path, f"{exe_basename}.spec")
            with open(spec_file, 'w', encoding='utf-8') as f:
                f.write(spec_content)
            
            self.progress_var.set(40)
            
            # Build EXE v·ªõi PyInstaller
            build_cmd = [sys.executable, '-m', 'PyInstaller', '--clean', spec_file]
            
            # Ch·∫°y PyInstaller t·ª´ th∆∞ m·ª•c d·ª± √°n (ƒë·ªÉ t√¨m ƒë∆∞·ª£c xml_protector_runtime.py)
            current_dir = os.getcwd()
            result = subprocess.run(build_cmd, cwd=current_dir, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.progress_var.set(100)
                self.build_status_label.configure(text="‚úÖ Build EXE th√†nh c√¥ng!")
                
                # T√¨m file EXE ƒë√£ t·∫°o (PyInstaller t·∫°o trong th∆∞ m·ª•c hi·ªán t·∫°i)
                dist_path = os.path.join(current_dir, 'dist', exe_name)
                
                # N·∫øu output_path kh√°c current_dir, move file EXE sang ƒë√≥
                if output_path != current_dir and os.path.exists(dist_path):
                    target_dist = os.path.join(output_path, 'dist')
                    os.makedirs(target_dist, exist_ok=True)
                    target_exe = os.path.join(target_dist, exe_name)
                    shutil.move(dist_path, target_exe)
                    exe_path = target_exe
                else:
                    exe_path = dist_path
                
                if os.path.exists(exe_path):
                    messagebox.showinfo("Th√†nh c√¥ng", 
                        f"EXE ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!\n\n"
                        f"üìÅ V·ªã tr√≠: {exe_path}\n"
                        f"üìä K√≠ch th∆∞·ªõc: {os.path.getsize(exe_path):,} bytes")
                else:
                    messagebox.showwarning("C·∫£nh b√°o", 
                        "EXE ƒë√£ ƒë∆∞·ª£c build nh∆∞ng kh√¥ng t√¨m th·∫•y file ƒë·∫ßu ra!")
            else:
                raise Exception(f"PyInstaller build failed: {result.stderr}")
            
        except Exception as e:
            self.build_status_label.configure(text="‚ùå Build EXE th·∫•t b·∫°i!")
            messagebox.showerror("L·ªói", f"Build EXE th·∫•t b·∫°i: {e}")
            self.progress_var.set(0)
    
    def deploy_to_telegram(self):
        """G·ª≠i EXE l√™n Telegram."""
        try:
            # T√¨m file EXE m·ªõi nh·∫•t
            exe_name = self.exe_name_entry.get().strip() or "quang_ninh.exe"
            output_path = self.output_path_entry.get().strip() or "."
            
            exe_file = Path(output_path) / "dist" / exe_name
            
            if not exe_file.exists():
                messagebox.showerror("L·ªói", f"Kh√¥ng t√¨m th·∫•y file EXE: {exe_file}")
                return
            
            # Ki·ªÉm tra k√≠ch th∆∞·ªõc file (Telegram limit 50MB)
            file_size = exe_file.stat().st_size
            if file_size > 50 * 1024 * 1024:  # 50MB
                messagebox.showerror("L·ªói", f"File EXE qu√° l·ªõn ({file_size/(1024*1024):.1f}MB). Telegram ch·ªâ h·ªó tr·ª£ t·ªëi ƒëa 50MB!")
                return
            
            # Chu·∫©n b·ªã th√¥ng tin
            bot_token = self.bot_token_entry.get().strip()
            chat_id = self.chat_id_entry.get().strip()
            
            if not bot_token or not chat_id:
                messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p Bot Token v√† Chat ID!")
                return
            
            # Hi·ªÉn th·ªã ti·∫øn tr√¨nh
            self.build_status_label.configure(text="üì§ ƒêang g·ª≠i EXE l√™n Telegram...")
            self.progress_var.set(50)
            
            # G·ª≠i file
            url = f"https://api.telegram.org/bot{bot_token}/sendDocument"
            
            with open(exe_file, 'rb') as f:
                files = {'document': f}
                data = {
                    'chat_id': chat_id,
                    'caption': f"""
üèóÔ∏è **XML PROTECTOR EXE M·ªöI**

üìÑ **File:** `{exe_name}`
üì¶ **K√≠ch th∆∞·ªõc:** `{file_size/(1024*1024):.1f}MB`
üïê **Build time:** `{time.strftime('%Y-%m-%d %H:%M:%S')}`
üíª **Build b·ªüi:** XML Protector Builder

‚úÖ S·∫µn s√†ng tri·ªÉn khai!
""",
                    'parse_mode': 'Markdown'
                }
                
                response = requests.post(url, files=files, data=data, timeout=300)
            
            if response.status_code == 200:
                self.build_status_label.configure(text="‚úÖ ƒê√£ g·ª≠i EXE l√™n Telegram th√†nh c√¥ng!")
                self.progress_var.set(100)
                messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ g·ª≠i {exe_name} l√™n Telegram th√†nh c√¥ng!")
            else:
                error_msg = response.json().get('description', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                self.build_status_label.configure(text="‚ùå L·ªói g·ª≠i Telegram")
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ g·ª≠i EXE l√™n Telegram: {error_msg}")
            
        except Exception as e:
            self.build_status_label.configure(text="‚ùå L·ªói g·ª≠i Telegram")
            messagebox.showerror("L·ªói", f"L·ªói g·ª≠i EXE l√™n Telegram: {e}")
    
    def create_download_link(self):
        """T·∫°o link download."""
        try:
            # T√¨m file EXE
            exe_name = self.exe_name_entry.get().strip() or "quang_ninh.exe"
            output_path = self.output_path_entry.get().strip() or "."
            
            exe_file = Path(output_path) / "dist" / exe_name
            
            if not exe_file.exists():
                messagebox.showerror("L·ªói", f"Kh√¥ng t√¨m th·∫•y file EXE: {exe_file}")
                return
            
            # T·∫°o th∆∞ m·ª•c share n·∫øu ch∆∞a c√≥
            share_dir = Path("shared_files")
            share_dir.mkdir(exist_ok=True)
            
            # Copy file EXE v√†o th∆∞ m·ª•c share
            shared_exe = share_dir / exe_name
            shutil.copy2(exe_file, shared_exe)
            
            # T·∫°o link download local
            download_link = f"file:///{shared_exe.absolute()}"
            
            # Hi·ªÉn th·ªã th√¥ng tin
            file_size = shared_exe.stat().st_size
            link_info = f"""
üì• **LINK DOWNLOAD ƒê√É T·∫†O**

üìÑ **File:** {exe_name}
üì¶ **K√≠ch th∆∞·ªõc:** {file_size/(1024*1024):.1f}MB
üìÇ **V·ªã tr√≠:** {shared_exe.absolute()}
üîó **Link Local:** {download_link}

üí° **H∆∞·ªõng d·∫´n:**
1. File ƒë√£ ƒë∆∞·ª£c copy v√†o th∆∞ m·ª•c 'shared_files'
2. C√≥ th·ªÉ chia s·∫ª file n√†y qua:
   - USB/CD/DVD
   - Email (n·∫øu file nh·ªè)
   - Cloud storage (Google Drive, OneDrive...)
   - Local network share

‚úÖ File s·∫µn s√†ng chia s·∫ª!
"""
            
            messagebox.showinfo("Link Download", link_info)
            
            # M·ªü th∆∞ m·ª•c ch·ª©a file
            import subprocess
            subprocess.run(['explorer', str(share_dir.absolute())], shell=True)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫°o link download: {e}")
    
    def refresh_clients(self):
        """L√†m m·ªõi danh s√°ch clients."""
        # TODO: Implement refresh clients
        pass
    
    def delete_client(self):
        """X√≥a client."""
        # TODO: Implement delete client
        pass
    
    def refresh_status(self):
        """L√†m m·ªõi tr·∫°ng th√°i h·ªá th·ªëng."""
        try:
            # System info
            # T√°ch logic ph·ª©c t·∫°p ra
            bot_status = 'üü¢ ƒêang ch·∫°y' if self.admin_bot else 'üî¥ ƒê√£ d·ª´ng'
            templates_count = len(glob.glob(os.path.join(self.templates_folder_entry.get(), '*.xml'))) if self.templates_folder_entry.get() else 0
            
            system_info = f"""
üíª **TH√îNG TIN H·ªÜ TH·ªêNG**

üñ•Ô∏è **OS:** {os.name}
üêç **Python:** {sys.version}
üìÅ **Th∆∞ m·ª•c hi·ªán t·∫°i:** {os.getcwd()}
‚è∞ **Th·ªùi gian:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üìä **TR·∫†NG TH√ÅI**
ü§ñ **Admin Bot:** {bot_status}
üìÅ **Templates:** {templates_count} files
"""
            
            self.system_status_text.delete('1.0', 'end')
            self.system_status_text.insert('1.0', system_info)
            
            # System logs
            self.system_logs_text.delete('1.0', 'end')
            self.system_logs_text.insert('1.0', "üìã Log h·ªá th·ªëng s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y...")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l√†m m·ªõi tr·∫°ng th√°i: {e}")
    
    def load_config(self):
        """Load config v√†o GUI."""
        try:
            # Telegram config
            self.bot_token_entry.delete(0, 'end')
            self.bot_token_entry.insert(0, self.config['telegram']['bot_token'])
            
            self.chat_id_entry.delete(0, 'end')
            self.chat_id_entry.insert(0, self.config['telegram']['chat_id'])
            
            self.admin_ids_entry.delete(0, 'end')
            admin_ids_str = ', '.join(map(str, self.config['telegram']['admin_ids']))
            self.admin_ids_entry.insert(0, admin_ids_str)
            
            # XML config
            self.templates_folder_entry.delete(0, 'end')
            self.templates_folder_entry.insert(0, self.config['xml_templates']['input_folder'])
            
            self.exe_name_entry.delete(0, 'end')
            self.exe_name_entry.insert(0, self.config['xml_templates']['output_exe_name'])
            
            # Output path
            if hasattr(self, 'output_path_entry'):
                self.output_path_entry.delete(0, 'end')
                output_path = self.config['xml_templates'].get('output_path', os.getcwd())
                self.output_path_entry.insert(0, output_path)
            
            # Build settings
            self.auto_send_var.set(self.config['build_settings']['auto_send_telegram'])
            self.include_guardian_var.set(self.config['build_settings']['include_guardian'])
            self.include_admin_bot_var.set(self.config['build_settings']['include_admin_bot'])
            self.auto_startup_var.set(self.config['build_settings']['auto_startup'])
            
            # Refresh XML list (n·∫øu ƒë√£ ch·ªçn th∆∞ m·ª•c)
            if self.templates_folder_entry.get().strip():
                self.refresh_xml_list()
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ load config: {e}")
    
    # C√°c h√†m ph√¢n t√≠ch XML c≈© ƒë√£ ƒë∆∞·ª£c thay th·∫ø b·∫±ng quick_analyze_xml
    
    def quick_analyze_xml(self):
        """Ph√¢n t√≠ch nhanh XML trong th∆∞ m·ª•c ƒë√£ ch·ªçn."""
        folder = self.templates_folder_entry.get().strip()
        if not folder or not os.path.exists(folder):
            messagebox.showwarning("C·∫£nh b√°o", "‚ö†Ô∏è Vui l√≤ng ch·ªçn th∆∞ m·ª•c XML g·ªëc tr∆∞·ªõc!")
            return
        
        try:
            xml_files = glob.glob(os.path.join(folder, "*.xml"))
            if not xml_files:
                messagebox.showinfo("Th√¥ng b√°o", "üìÇ Kh√¥ng c√≥ file XML n√†o ƒë·ªÉ ph√¢n t√≠ch!")
                return
            
            # Ph√¢n t√≠ch nhanh
            analysis_result = []
            analysis_result.append(f"üîç PH√ÇN T√çCH NHANH: {Path(folder).name}")
            analysis_result.append("=" * 50)
            analysis_result.append(f"üìÅ T·ªïng s·ªë file: {len(xml_files)}")
            
            # Th·ªëng k√™ k√≠ch th∆∞·ªõc
            total_size = sum(os.path.getsize(f) for f in xml_files)
            analysis_result.append(f"üìä T·ªïng k√≠ch th∆∞·ªõc: {total_size/1024/1024:.2f} MB")
            
            # Ph√¢n t√≠ch t·ª´ng file
            for i, xml_file in enumerate(xml_files[:5], 1):  # Ch·ªâ hi·ªÉn th·ªã 5 file ƒë·∫ßu
                filename = Path(xml_file).name
                size_kb = os.path.getsize(xml_file) / 1024
                analysis_result.append(f"\nüìÑ {i}. {filename} ({size_kb:.1f} KB)")
                
                try:
                    # Ph√¢n t√≠ch c∆° b·∫£n
                    tree = ET.parse(xml_file)
                    root = tree.getroot()
                    
                    # T√¨m c√°c tr∆∞·ªùng quan tr·ªçng - T√åM KI·∫æM TH√îNG MINH H∆†N
                    found_fields = []
                     
                    # Danh s√°ch c√°c tr∆∞·ªùng c·∫ßn t√¨m (c√≥ th·ªÉ c√≥ namespace)
                    field_patterns = [
                        # MST - M√£ s·ªë thu·∫ø
                        './/mst', './/MST', './/maSoThue', './/MaSoThue',
                        # T√™n doanh nghi·ªáp
                        './/tenNNT', './/TenNNT', './/companyName', './/CompanyName', './/tenCongTy',
                        # M√£ t·ªù khai
                        './/maTKhai', './/MaTKhai', './/maTkhai', './/MaTkhai',
                        # K·ª≥ khai
                        './/kyKKhai', './/KyKKhai', './/kyKhai', './/KyKhai',
                        # C√°c tr∆∞·ªùng kh√°c
                        './/ngayKhai', './/NgayKhai', './/thangKhai', './/ThangKhai',
                        './/namKhai', './/NamKhai', './/tongTien', './/TongTien'
                    ]
                    
                    for pattern in field_patterns:
                        try:
                            elements = root.findall(pattern)
                            if elements:
                                for elem in elements:
                                    if elem.text and elem.text.strip():
                                        field_name = pattern.split('//')[-1]  # L·∫•y t√™n tr∆∞·ªùng
                                        field_value = elem.text.strip()
                                        # Gi·ªõi h·∫°n ƒë·ªô d√†i ƒë·ªÉ d·ªÖ ƒë·ªçc
                                        if len(field_value) > 50:
                                            field_value = field_value[:50] + "..."
                                        found_fields.append(f"{field_name}: {field_value}")
                                        break  # Ch·ªâ l·∫•y tr∆∞·ªùng ƒë·∫ßu ti√™n t√¨m th·∫•y
                        except:
                            continue
                    
                    if found_fields:
                        # Hi·ªÉn th·ªã t·ªëi ƒëa 4 tr∆∞·ªùng quan tr·ªçng nh·∫•t
                        display_fields = found_fields[:4]
                        analysis_result.append(f"   ‚úÖ {', '.join(display_fields)}")
                    else:
                        # Th·ª≠ t√¨m t·∫•t c·∫£ c√°c element c√≥ text
                        all_elements = []
                        for elem in root.iter():
                            if elem.text and elem.text.strip() and len(elem.text.strip()) > 3:
                                tag_name = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
                                all_elements.append(f"{tag_name}: {elem.text.strip()[:30]}")
                                if len(all_elements) >= 3:
                                    break
                        
                        if all_elements:
                            analysis_result.append(f"   üîç T√¨m th·∫•y: {', '.join(all_elements)}")
                        else:
                            analysis_result.append(f"   ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng c√≥ d·ªØ li·ªáu")
                        
                except Exception as e:
                    analysis_result.append(f"   ‚ùå L·ªói ph√¢n t√≠ch: {str(e)[:50]}...")
            
            if len(xml_files) > 5:
                analysis_result.append(f"\n... v√† {len(xml_files) - 5} file kh√°c")
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            result_text = '\n'.join(analysis_result)
            messagebox.showinfo("Ph√¢n T√≠ch Nhanh", result_text)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"‚ùå Kh√¥ng th·ªÉ ph√¢n t√≠ch XML: {e}")
    
    def browse_output_path(self):
        """Ch·ªçn th∆∞ m·ª•c ƒë·∫ßu ra cho EXE."""
        output_path = filedialog.askdirectory(
            title="Ch·ªçn th∆∞ m·ª•c ƒë·∫ßu ra cho EXE"
        )
        if output_path:
            self.output_path_entry.delete(0, 'end')
            self.output_path_entry.insert(0, output_path)
    
    def save_config(self):
        """L∆∞u config t·ª´ GUI."""
        try:
            # Telegram config
            self.config['telegram']['bot_token'] = self.bot_token_entry.get().strip()
            self.config['telegram']['chat_id'] = self.chat_id_entry.get().strip()
            
            admin_ids_str = self.admin_ids_entry.get().strip()
            self.config['telegram']['admin_ids'] = [int(x.strip()) for x in admin_ids_str.split(',') if x.strip()]
            
            # XML config
            self.config['xml_templates']['input_folder'] = self.templates_folder_entry.get().strip()
            self.config['xml_templates']['output_exe_name'] = self.exe_name_entry.get().strip()
            
            # Output path
            if hasattr(self, 'output_path_entry'):
                self.config['xml_templates']['output_path'] = self.output_path_entry.get().strip()
            
            # Build settings
            self.config['build_settings']['auto_send_telegram'] = self.auto_send_var.get()
            self.config['build_settings']['include_guardian'] = self.include_guardian_var.get()
            self.config['build_settings']['include_admin_bot'] = self.include_admin_bot_var.get()
            self.config['build_settings']['auto_startup'] = self.auto_startup_var.get()
            
            # L∆∞u file
            with open('xml_protector_config.json', 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            
            messagebox.showinfo("Th√†nh c√¥ng", "Config ƒë√£ ƒë∆∞·ª£c l∆∞u!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u config: {e}")
    
    # === ENTERPRISE MANAGEMENT METHODS === #
    
    def add_company(self):
        """Th√™m doanh nghi·ªáp m·ªõi."""
        try:
            mst = self.company_mst_entry.get().strip()
            company_name = self.company_name_entry.get().strip()
            exe_name = self.company_exe_entry.get().strip()
            
            if not all([mst, company_name, exe_name]):
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!")
                return
            
            # Ki·ªÉm tra MST ƒë√£ t·ªìn t·∫°i ch∆∞a
            if mst in self.companies_data:
                messagebox.showerror("L·ªói", f"MST {mst} ƒë√£ t·ªìn t·∫°i!")
                return
            
            # T·∫°o company data
            company_data = {
                "mst": mst,
                "name": company_name,
                "exe_name": exe_name if exe_name.endswith('.exe') else exe_name + '.exe',
                "status": "Ch∆∞a deploy",
                "templates_count": 0,
                "last_deploy": "Ch∆∞a bao gi·ªù",
                "created_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "deployment_id": str(uuid.uuid4())[:8].upper(),
                "telegram_config": {
                    "bot_token": self.bot_token_entry.get().strip(),
                    "chat_id": self.chat_id_entry.get().strip(),
                    "admin_ids": self.parse_admin_ids()
                }
            }
            
            # L∆∞u v√†o companies_data
            self.companies_data[mst] = company_data
            
            # C·∫≠p nh·∫≠t config
            self.config["companies"][mst] = company_data
            
            # Refresh UI
            self.refresh_companies_list()
            
            # Clear form
            self.company_mst_entry.delete(0, 'end')
            self.company_name_entry.delete(0, 'end')
            self.company_exe_entry.delete(0, 'end')
            
            messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ th√™m doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ th√™m doanh nghi·ªáp: {e}")
    
    def refresh_companies_list(self):
        """L√†m m·ªõi danh s√°ch doanh nghi·ªáp."""
        # Clear existing items
        for item in self.companies_tree.get_children():
            self.companies_tree.delete(item)
        
        # Add companies
        for mst, company_data in self.companies_data.items():
            self.companies_tree.insert('', 'end', values=(
                company_data["mst"],
                company_data["name"],
                company_data["exe_name"],
                company_data["status"],
                company_data["templates_count"],
                company_data["last_deploy"],
                "üîß Qu·∫£n l√Ω"
            ))
    
    def select_company_for_build(self):
        """Ch·ªçn doanh nghi·ªáp ƒë·ªÉ build."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            company_name = item['values'][1]
            exe_name = item['values'][2]
            
            # Update UI v·ªõi th√¥ng tin company ƒë√£ ch·ªçn
            self.selected_company_label.configure(
                text=f"üìå ƒê√£ ch·ªçn: {company_name} ({mst})",
                foreground="green"
            )
            
            # Auto-fill exe name
            self.exe_name_entry.delete(0, 'end')
            self.exe_name_entry.insert(0, exe_name)
            
            messagebox.showinfo("ƒê√£ ch·ªçn", f"‚úÖ ƒê√£ ch·ªçn doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ch·ªçn doanh nghi·ªáp: {e}")
    
    def edit_selected_company(self):
        """S·ª≠a th√¥ng tin doanh nghi·ªáp ƒë√£ ch·ªçn."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp ƒë·ªÉ s·ª≠a!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            
            # Fill form v·ªõi th√¥ng tin hi·ªán t·∫°i
            company_data = self.companies_data.get(mst)
            if company_data:
                self.company_mst_entry.delete(0, 'end')
                self.company_mst_entry.insert(0, company_data["mst"])
                
                self.company_name_entry.delete(0, 'end')
                self.company_name_entry.insert(0, company_data["name"])
                
                self.company_exe_entry.delete(0, 'end')
                self.company_exe_entry.insert(0, company_data["exe_name"])
                
                messagebox.showinfo("Th√¥ng b√°o", f"ƒê√£ load th√¥ng tin {company_data['name']} v√†o form.\nS·ª≠a v√† nh·∫•n 'C·∫≠p Nh·∫≠t DN' ƒë·ªÉ l∆∞u.")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ s·ª≠a doanh nghi·ªáp: {e}")
    
    def delete_selected_company(self):
        """X√≥a doanh nghi·ªáp ƒë√£ ch·ªçn."""
        try:
            selected = self.companies_tree.selection()
            if not selected:
                messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt doanh nghi·ªáp ƒë·ªÉ x√≥a!")
                return
            
            item = self.companies_tree.item(selected[0])
            mst = item['values'][0]
            company_name = item['values'][1]
            
            # X√°c nh·∫≠n x√≥a
            confirm = messagebox.askyesno(
                "X√°c nh·∫≠n x√≥a", 
                f"‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a doanh nghi·ªáp:\n\n"
                f"MST: {mst}\n"
                f"T√™n: {company_name}\n\n"
                f"H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!"
            )
            
            if confirm:
                # X√≥a kh·ªèi data
                if mst in self.companies_data:
                    del self.companies_data[mst]
                
                if mst in self.config["companies"]:
                    del self.config["companies"][mst]
                
                # Refresh UI
                self.refresh_companies_list()
                
                # Clear selection label n·∫øu company n√†y ƒëang ƒë∆∞·ª£c ch·ªçn
                if mst in self.selected_company_label.cget("text"):
                    self.selected_company_label.configure(
                        text="üìå Ch∆∞a ch·ªçn doanh nghi·ªáp n√†o",
                        foreground="blue"
                    )
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ x√≥a doanh nghi·ªáp: {company_name}")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ x√≥a doanh nghi·ªáp: {e}")
    
    def export_companies_list(self):
        """Export danh s√°ch doanh nghi·ªáp ra file."""
        try:
            if not self.companies_data:
                messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ doanh nghi·ªáp n√†o ƒë·ªÉ export!")
                return
            
            # Ch·ªçn n∆°i l∆∞u file
            from tkinter import filedialog
            filename = filedialog.asksaveasfilename(
                title="Export danh s√°ch doanh nghi·ªáp",
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
            )
            
            if filename:
                export_data = {
                    "exported_at": datetime.now().isoformat(),
                    "total_companies": len(self.companies_data),
                    "companies": self.companies_data
                }
                
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ export {len(self.companies_data)} doanh nghi·ªáp ra file:\n{filename}")
        
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ export: {e}")
    
    def parse_admin_ids(self):
        """Parse admin IDs t·ª´ entry."""
        try:
            admin_ids_str = self.admin_ids_entry.get().strip()
            if admin_ids_str:
                return [int(x.strip()) for x in admin_ids_str.split(',') if x.strip()]
            return []
        except:
            return []
    
    def save_secure_config(self):
        """L∆∞u config v·ªõi m√£ h√≥a."""
        try:
            # Update telegram config
            self.config["telegram"]["bot_token"] = self.bot_token_entry.get().strip()
            self.config["telegram"]["master_chat_id"] = self.chat_id_entry.get().strip()
            self.config["telegram"]["admin_ids"] = self.parse_admin_ids()
            
            # Update master admin info
            self.config["master_admin"]["created_at"] = datetime.now().isoformat()
            
            # Save v·ªõi security manager n·∫øu c√≥
            if self.security_manager and self.config_manager:
                # T·∫°o master config file
                master_config_file = Path("master_config.enc")
                with open(master_config_file, 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", "‚úÖ Config ƒë√£ ƒë∆∞·ª£c l∆∞u v·ªõi m√£ h√≥a!")
            else:
                # Fallback - save normal file
                with open('xml_protector_config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("Th√†nh c√¥ng", "‚úÖ Config ƒë√£ ƒë∆∞·ª£c l∆∞u!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u config: {e}")
    
    def load_secure_config(self):
        """Load config an to√†n."""
        try:
            # Th·ª≠ load t·ª´ master config tr∆∞·ªõc
            master_config_file = Path("master_config.enc")
            if master_config_file.exists():
                with open(master_config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
                    self.companies_data = self.config.get("companies", {})
            else:
                # Fallback - load t·ª´ file c≈©
                old_config_file = Path('xml_protector_config.json')
                if old_config_file.exists():
                    with open(old_config_file, 'r', encoding='utf-8') as f:
                        old_config = json.load(f)
                        # Migrate old config
                        self.migrate_old_config(old_config)
            
            # Load v√†o GUI
            self.load_config_to_gui()
            
        except Exception as e:
            print(f"‚ö†Ô∏è Load config warning: {e}")
            # S·ª≠ d·ª•ng template m·∫∑c ƒë·ªãnh
            pass
    
    def migrate_old_config(self, old_config):
        """Migration t·ª´ config c≈© sang format m·ªõi."""
        try:
            # Migrate telegram settings
            if "telegram" in old_config:
                self.config["telegram"]["bot_token"] = old_config["telegram"].get("bot_token", "")
                self.config["telegram"]["master_chat_id"] = old_config["telegram"].get("chat_id", "")
                self.config["telegram"]["admin_ids"] = old_config["telegram"].get("admin_ids", [])
            
            # Migrate build settings
            if "build_settings" in old_config:
                self.config["build_settings"].update(old_config["build_settings"])
            
            print("‚úÖ ƒê√£ migration config c≈© th√†nh c√¥ng")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Migration warning: {e}")
    
    def load_config_to_gui(self):
        """Load config v√†o GUI elements."""
        try:
            # Load telegram config
            telegram_config = self.config.get("telegram", {})
            
            self.bot_token_entry.delete(0, 'end')
            self.bot_token_entry.insert(0, telegram_config.get("bot_token", ""))
            
            self.chat_id_entry.delete(0, 'end')
            self.chat_id_entry.insert(0, telegram_config.get("master_chat_id", ""))
            
            self.admin_ids_entry.delete(0, 'end')
            admin_ids_str = ', '.join(map(str, telegram_config.get("admin_ids", [])))
            self.admin_ids_entry.insert(0, admin_ids_str)
            
            # Load companies
            self.refresh_companies_list()
            
        except Exception as e:
            print(f"‚ö†Ô∏è Load to GUI warning: {e}")
    
    def run(self):
        """Ch·∫°y GUI."""
        self.root.mainloop()

def main():
    """H√†m ch√≠nh."""
    print("üöÄ Kh·ªüi ƒë·ªông XML Protector - GUI Builder T√≠ch H·ª£p...")
    
    try:
        builder = XMLProtectorBuilder()
        builder.run()
    except Exception as e:
        print(f"‚ùå L·ªói kh·ªüi ƒë·ªông GUI: {e}")
        messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông GUI: {e}")

if __name__ == '__main__':
    main()

